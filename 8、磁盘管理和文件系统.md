# 1磁盘管理和文件系统

## 1.1磁盘存储

### 1.1.1设备文件

设备文件分类

```
在Linux系统中，设备文件主要可以分为以下三种类型：
字符设备文件：
 	字符设备文件是一种按字节流进行操作的设备，如串口、键盘、鼠标等。它们提供的是一种基于字符的输入输出接口，可以使用标准的文件操作函数（如read、write、open和close）对其进行操作。

块设备文件：
 	块设备文件是一种按块进行操作的设备，如硬盘、U盘等。它们提供的是一种基于块的输入输出接口，通常使用特定的块设备操作函数（如request_queue、submit_bio等）进行操作。

网络设备文件：
 	网络设备文件是一种用于网络通信的设备，如网卡等。它们提供的是一种基于数据包的输入输出接口，可以使用特定的网络操作函数（如sendmsg、recvmsg等）进行操作。
```

| 设备号   | 英文         | 作用                     |
| -------- | ------------ | ------------------------ |
| 主设备号 | major number | 标识设备类型             |
| 次设备号 | minor number | 标识同一类型下的不同设备 |

| 设备类型                  | 设备文件命名                             |
| :------------------------ | :--------------------------------------- |
| SAS，SATA，SCSI，IDE，USB | /dev/sda; /dev/sdb; /dev/sdc             |
| nvme协议硬盘              | /dev/nvme0n1; /dev/nvme0n2; /dev/nvme0n3 |
| 虚拟磁盘(虚拟环境下)      | /dev/vda; /dev/vdb; /dev/xvda; /dev/xvdb |

scsi_host文件里面的值分别是什么意思？

```
在/sys/class/scsi_host/hostx/proc_name文件中，常见的内容有ahci、mptspi、ata_piix
等信息，这些值通常用于标识和区分SCSI总线上不同设备的类型或控制器的特性。
```

虚拟机模拟热插拔效果，添加硬盘，不重启识别

```
[root@rocky9 ~]# echo '- - -' > /sys/class/scsi_host/host0/scan 
[root@rocky9 ~]# echo '- - -' > /sys/class/scsi_host/host1/scan 
[root@rocky9 ~]# echo '- - -' > /sys/class/scsi_host/host2/scan
```

### 1.1.2硬盘，存储术语



```
注意：硬盘有价，数据无价，目前SSD不能完全取代HHD
硬盘（Hard Disk Drive, HDD）
 	传统的硬盘类型，采用磁性存储技术，通过盘片的旋转和磁头的移动来读写数据。
 	存储容量大、价格相对较低，但读写速度相对较慢，且存在机械结构，易受震动影响。
固态硬盘（Solid State Drive, SSD）
 	采用闪存芯片作为存储介质的新型硬盘，没有机械结构，因此读写速度极快，抗震性能优越。
 	价格相对较高，但随着技术进步逐渐亲民；存储容量虽然有限，但已能满足大多数应用需求；适用于需要高读写速度和稳定性的场景。
```

| 术语 | 英文                               | 描述                                                         |
| ---- | ---------------------------------- | ------------------------------------------------------------ |
| 磁头 | head                               | 一个盘面对应一个磁头                                         |
| 磁道 | track                              | 盘面上的每一圈就是一个磁道                                   |
| 扇区 | sector                             | 把每个磁道按512bytes大小再进行划分，这就是扇区，每个磁道上的扇区数量是不一样的 |
| 柱面 | cylinder                           | 磁头移动的时候，是一起移动的，如果是6个盘面，则6个磁头对应的磁道是一致的，这就是柱面 |
| 分区 | Partition                          | 硬盘上逻辑上独立的空间，用于存储数据和安装操作系统。包括主分区、扩展分区和逻辑分区。主分区和逻辑分区都可以用于存储数据和安装操作系统；扩展分区则是一个指向下一个分区的指针，用于管理多个逻辑分区。 |
| NVMe | Non-Volatile Memory Express        | 一种专门用于访问固态硬盘（SSD）和其他非易失性内存设备的通信协议和接口规范,提供比传统存储接口更快的性能，广泛应用于现代计算系统中。 |
| IOPs | Input/Output Operations Per Second | 每秒输入/输出操作次数，是衡量硬盘性能的重要指标之一。对于大量小数据量的随机读写应用，IOPS比带宽更为重要。 |
| 带宽 | Bandwidth                          | 硬盘数据传输的速率，通常以MB/s或GB/s为单位表示。对于大块顺序读写的应用，带宽是衡量硬盘性能的关键因素。 |

MBR&ZBR

```
	MBR（Master Boot Record, MBR）的作用至关重要，硬盘的第一个扇区（0道0头1扇区），包含硬盘的主引导程序和分区表。它是计算机启动的关键，包含了引导代码，能够加载操作系统，并告诉计算机硬盘上的分区信息。
 	ZBR（Zoned Bit Recording），即区位记录，是一种物理优化硬盘存储空间的方法。与传统的硬盘存储方式相比，ZBR不再采用每个磁道扇区数固定的方式，而是根据磁道半径的不同，将更多的扇区放到磁盘的外部磁道，以获取更多的存储空间。这种设计使得外部磁道的数据传输速度要快于内部磁道，因为单位时间内扫过的扇区数在外部磁道更多
```

```
磁盘寻址是指计算机在硬盘上定位到数据所在的物理地址的过程。简单来说，就是磁头在盘片上找到并读取或写入数据的具体位置。当计算机需要读取或写入硬盘上的数据时，它会通过以下步骤进行磁盘寻址：
 	- 确定柱面：确定数据所在的柱面，是通过计算数据的逻辑地址并转换为物理地址来实现的。
 	- 选择磁头：选择正确的磁头来读取或写入数据。每个磁头负责一个盘面的读写操作。
 	- 定位扇区：定位到柱面上的特定扇区来读取或写入数据。这通常是通过扇区号来实现的。
```

```
磁盘上寻址的两种方式
CHS（Cylinder-Head-Sector 柱面-磁头-扇区）也称为3D模式
 - 它通过提供柱面号、磁头号和扇区号来唯一确定一个扇区的位置。
    - CHS采用 24 bit位寻址
    - 其中前10位表示cylinder，中间8位表示head，后面6位表示sector 
    - 最大寻址空间 8 GB
    - 是硬盘最早采用的寻址模式之一。
LBA （logical block addressing）
    - LBA是一个整数，通过转换成 CHS 格式完成磁盘具体寻址
    - ATA-1规范中定义了28位寻址模式，以每扇区512位组来计算，ATA-1所定义的28位LBA上限达到128 GiB。2002年ATA-6规范采用48位LBA，同样以每扇区512位组计算容量上限可达128 Petabytes
    - 它基于扇区的线性编号来定位数据,不受柱面、磁头和扇区的限制。
    - 在现代硬盘中，LBA寻址方式已经成为主流。
```

```
	在磁盘容量小于大概8GB时，可以使用CHS寻址方式或是LBA寻址方式；
 	在磁盘容量大于大概8GB时，则只能使用LBA寻址方式
```

```
	磁盘寻址是计算机存储系统中的一个关键环节。它决定了数据在硬盘上的存储位置，并影响着计算机的读写性能。高效的磁盘寻址算法可以缩短数据的访问时间，提高计算机的响应速度。因此，在设计和优化存储系统时，需要充分考虑磁盘寻址的方式和效率。
```

CHS信息

```
注意：如果你的vm主机在创建的时候，选择的是
 	NVMe格式，那么磁盘的名称是：/dev/nvme0n1
 	iscsi格式，那么磁盘的名称是 /dev/sda
```

查看磁盘类型

```
lsblk -d -o name,rota		#1表示机械磁盘，0表示SSD磁盘
ls /sys/block/

查看其他几个文件
cat /sys/block/*/queue/rotational
cat /sys/block/sda/queue/rotational
```

fdisk查看分区效果

```
fdisk -l /dev/sda
```

### 1.1.4常见命令df、du、dd

文件系统查看工具

```
格式
	df 选项 文件名/文件类型
选项
	-T		#显示文件系统类型
	-h		#以方便阅读的方式显示
	-t		#指定文件系统类型查看
	-x 		#指定文件系统类型取反查看 -- 反向过滤
```

文件系统目录信息统计工具 du

```
格式
	du 选项 文件路径
	du 选项 --files0-from=F
选项
	-h 		#查看目录下所有文件目录的大小信息
	-sh		#查看指定目录空间大小信息
```

文件系统文件定制工具 dd

```
格式
	dd 选项
	dd 选项 ...
常用格式
	dd if=/PATH/FROM/SRC of=/PATH/TO/DEST  bs=N count=N
	dd if=来源文件 of=输出文件 skip=要忽略的大小 bs=每次操作块的大小 count=一次性处理多少个文件块
	dd if=fileA of=fileB bs=1 count=128 skip=63 seek=31 conv=notrunc
			#读取到的128Bytes写到第32个字节开始的位置，替换128Bytes
```

### 1.1.5总结

```
设备标号 sd nvme vd

机械磁盘 | 固态磁盘

寻址类型  CHS | LBA

设备文件 有自己的标识,主设备号、次设备号

如何在vm 主机上，快速看到新增的磁盘信息
	正常方法： 重启主机即可
	快速生效：
			grep mptspi /sys/class/scsi_host/host*/proc_name
			echo '- - -' > /sys/class/scsi_host/host2/scan
			
物理磁盘 		/dev/sda
ssd				/dev/nvme0n1
虚拟磁盘		/dev/vda

磁盘类型：
    传统的物理磁盘，类型是 按照接口来进行划分
    
服务器里面用的大磁盘 3.5寸
普通电脑用的小磁盘 2.5寸

传统的盘数据存在 盘面
新型的盘数据存在 存储颗粒

设备文件 
    /dev/null	#垃圾桶文件
    /dev/zero	#向外不断输出0
    
```

## 1.2 存储管理

### 1.2.1基础知识

基本步骤

```
当我们拿到一块物理磁盘的时候，我们可以按照如下的步骤，实现在服务器中使用使用磁盘空间的效果
1. 设备分区
2. 创建文件系统
3. 挂载新的文件系统
```

磁盘分区

```
磁盘分区是指将一个硬盘划分为多个独立的存储区域，每个区域都拥有自己的文件系统和卷标。这种划分
方式使得用户可以更方便地管理和存储不同类型的文件。磁盘分区是计算机存储管理的重要基础，对于提高数
据存储的效率和安全性具有重要意义
```

常见分区类型

主分区 扩展分区 逻辑分区 非引导分区

MBR&GPT

```
MBR分区表最多支持4个主分区，或者3个主分区和1个扩展分区（扩展分区下可以创建多个逻辑分区）
由于MBR使用32位的LBA（Logical Block Addressing）寻址方式，其最大可寻址的存储空间只有
2TB（2^32个扇区，每个扇区512字节）。
```

```
	GPT是一种现代的磁盘分区方案，由EFI（Extensible Firmware Interface，可扩展固件接口）标准提出并推广。GPT旨在克服MBR所存在的一些限制，并提供更多的功能和灵活性。
	GPT可以支持最多128个分区
	数据冗余与校验：
 		GPT在硬盘两端各保存一份分区表副本，以及CRC32校验，有助于提高数据完整性和容错性
 	GPT分区表中的每个分区项都有一个唯一的GUID（Globally Unique Identifier，全局唯一标识符），这有助于防止分区表被恶意篡改或误操作。同时，GPT的分区表结构更加清晰和灵活，便于管理和维护。
```

BOIS&EFI

```
BIOS 是固化在电脑主板上的程序，主要用于开机系统自检和引导操作系统。目前新式的电脑基本上都是
UEFI启动
```

```
EFI（Extensible Firmware Interface）可扩展固件接口，是 Intel 为PC 固件的体系结构、接
口和服务提出的建议标准。其主要目的是为了提供一组在 OS 加载之前（启动前）在所有平台上一致的、正确
指定的启动服务，被看做是BIOS的继任者，或者理解为新版BIOS。
```

```
	BIOS采用了16位汇编语言编写，只能运行在实模式（内存寻址方式由16位段寄存器的内容乘以16(10H) 当做段基地址，加上16位偏移地址形成20位的物理地址）下，可访问的内存空间为1MB，只支持字符操作界面。
 	也就是说，BIOS相关的信息，烧录到BIOS芯片里面，然后固定到电脑主板上了。而我们启动电脑后，修改的BIOS属性信息保存在另外一个主板芯片上，所以主板上需要有一块纽扣电池来保证主板芯片能够正常运行。
 	UEFI采用32位或者64位的C语言编写，突破了实模式的限制，可以达到最大的寻址空间，支持图形操作界面，使用文件方式保存信息，支持GPT分区启动，适合和较新的系统和硬件的配合使用
```

```
常见组合方案：
 BIOS+MBR 与 UEFI+GPT
```

### 1.2.2 MBR方案

```
MBR分区方案，其最大可寻址的存储空间只有2TB，也就是说总共2^32个扇区，每个扇区512字节。
-  446bytes: boot loader 启动相关
-  64bytes：分区表，其中每16bytes标识一个分区
-  2bytes: 55AA，标识位
```

```
hexdump -n 512 -Cv /dev/sda | tail -5
命令解读：
 -v 表示以“verbose”模式显示，
 -C 表示以十六进制和 ASCII 字符混合显示，
 -n 512 表示只显示前 512 字节。
```

分区样式

```
MBR分区中一块硬盘最多有4个主分区，也可以3主分区+1扩展(N个逻辑分区) 
MBR分区：
 主和扩展分区对应的1--4，/dev/sda3，
 逻辑分区从5开始，/dev/sda5
```

为什么MBR分区不能超过4个主分区?

```
	MBR（Master Boot Record，主引导记录）是硬盘上第一个扇区的内容，它包含了硬盘的分区信息、启动代码等重要数据。MBR分区表的大小是固定的，只有64字节，用于存储分区信息。每个分区项的关键项信息就占用16字节，因此理论上MBR分区表最多只能描述4个分区（64字节 / 16字节/分区 = 4个分区）。
 	非要超过4个分区，那就只能 使用扩展分区来做了。
```

为什么MBR分区的单分区不能超2T？

```
	一个分区信息占用16个字节，其中记录分区开始位置 和 结束位置的空间各为4个字节，一个字节8bit，所以记录分区位置的4个字节就是 4*8=32 位，也就是说，分区位置记录的数值范围是 2^0 ~2^32。
 	那么，一个分区最大能够支持的查找的扇区数量是 2^32 个，MBR的每个扇区占用空间是 512个字节，所以一个分区最大的支持存储空间就是 2^32 * 512 。
 	注意：B字节、K、M、T 的转换单位是 1024，也就是 2^10
 	2^32 * 2^9 = 2^41 字节 B
	2^41 B ÷ 2^10 = 2^31 KB
 	2^31 KB ÷ 2^10 = 2^21 MB
 	2^21 MB ÷ 2^10 = 2^11 GB
 	2^11 GB ÷ 2^10 = 2^1 TB
 
 	MBR分区受到容量的限制。由于MBR使用32位的LBA（Logical Block Addressing）寻址方式，其最大可寻址的存储空间只有2TB（2^32个扇区，每个扇区512字节）。这意味着，即使硬盘的实际容量超过2TB，使用MBR分区表也只能识别和使用其中的2TB空间。
```

```
硬盘主引导记录MBR由4个部分组成
    - 主引导程序（偏移地址0000H--0088H），它负责从活动分区中装载，并运行系统引导程序
    - 出错信息数据区，偏移地址0089H--00E1H为出错信息，00E2H--01BDH全为0字节
    - 分区表（DPT,Disk Partition Table）含4个分区项，偏移地址01BEH--01FDH,每个分区表项长
16个 字节，共64字节为分区项1、分区项2、分区项3、分区项4
    - 结束标志字，偏移地址01FE--01FF的2个字节值为结束标志55AA
```

### 1.2.3GPT分区

```
GPT分区，全称为GUID Partition Table（全局唯一标识分区表），是一种源自EFI（Extensible 
Firmware Interface，可扩展固件接口）标准的较新磁盘分区表结构。
```

特点

```
支持大硬盘： 
 	GPT分区使用64位的整数表示扇区号，因此理论上支持几乎无限大的硬盘容量，实际上可以支持超过2TB的硬盘，而MBR分区则受限于其32位表示方式，最高只能支持到2TB。
分区数量无限制：
 	使用128位UUID(Universally Unique Identifier) 表示磁盘和分区, GPT分区在理论上支持无限量的分区，但实际上受到操作系统的限制。
数据完整性和容错能力：
 	GPT分区表具有容灾功能，它会在磁盘的"首尾两部分"分别保存一份相同的分区表, 并有CRC校验位。当其中一份分区表被破坏时，可以通过另一份恢复，从而提高了数据的完整性和容错能力。
分区表位置：
 	GPT分区表位于硬盘的最后一个扇区，即GPT扇区，这与MBR分区表位于硬盘的第一个扇区和第二个扇区之间不同。这种设计使得GPT分区表更加安全，避免了因为分区表被损坏而导致的数据丢失。
每个分区可以命名：
 	GPT分区允许为每个分区指定一个名称（不同于卷标），这使得磁盘管理更加直观和方便。
 	
启动方便：
 	UEFI (Unified Extensible Firmware Interface 统一可扩展固件接口)硬件支持GPT，使得操作系统可以启动
```

结构图

```
GPT头、分区表、GPT分区 、备份区域
注意：ubuntu默认使用gpt分区
```

```
GPT分区表起始部分
 	GPT分区表使用全局唯一标识符（GUID）来标识分区，并在硬盘两端各保存一份分区表以增加容错性。
 	GPT分区表的起始部分包含了分区表头，定义了硬盘的可用空间以及组成分区表的项的大小和数量。
 	这部分空间还记录了硬盘的GUID，分区表头本身的位置和大小，以及备份分区表头和分区表的位置和大小。
 
4K对齐
 	4K对齐是一种硬盘分区格式，指的是符合4K扇区大小定义的一种技术，4K扇区大小为4096字节。
 	GPT磁盘在进行分区时，为了确保数据读写效率和性能，通常会进行4K对齐。
 	GPT分区表中，前面的1024KB（即1024k或1MB）空间通常是预留给分区表的起始部分以及确保4K对齐的
```

GPT磁盘的整体布局包括以下几个关键部分

```
保护MBR区域：
 	位于磁盘的第一个扇区（LBA0），主要用于兼容性考虑。这个区域存储了一份传统的MBR信息，以防止不支持GPT的硬盘管理工具错误识别并破坏硬盘中的数据。在这个MBR中，只有一个标识为0xEE的分区，表示这块硬盘使用GPT分区表。它的作用是阻止不能识别GPT分区的磁盘工具试图对其进行格式化等操作，所以该扇区被称为“保护MBR”。实际上，EFI根本不使用这个分区表。
 	
EFI部分：紧接着保护MBR区域，EFI部分又可以细分为几个子区域：
 	EFI信息区（GPT头）：
 		起始于磁盘的第二个扇区（LBA1），定义了分区表的位置和大小，还包含头和分区表的校验和，用于验证GPT头的完整性。
 	分区表区域：
 		包含了分区表项，一般占用磁盘LBA2至LBA33扇区。分区表中的每个分区项包含了分区的起始地址、结束地址、类型值、名字、属性标志和GUID值等信息。
 	GPT分区：
 		最大的区域，由分配给分区的扇区组成，这个区域的起始和结束地址由GPT头定义。
 	备份区域：
 		位于磁盘的尾部，包含GPT头和分区表的备份，用于在主GPT头或分区表损坏时进行恢复。
```

fdisk命令用于操作管理分区

```
格式
	fdisk [options] -l [<disk>]
选项
	-l|--list         	#以列表显示
```

```
root@rocky9:~ $ lsblk
NAME              MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
sda                 8:0    0   200G  0 disk 
├─sda1              8:1    0   600M  0 part /boot/efi
├─sda2              8:2    0     1G  0 part /boot
└─sda3              8:3    0 198.4G  0 part 
  ├─rl_bogon-root 253:0    0    70G  0 lvm  /
  ├─rl_bogon-swap 253:1    0     2G  0 lvm  [SWAP]
  └─rl_bogon-home 253:2    0 126.4G  0 lvm  /home
sdb                 8:16   0    10G  0 disk 
sr0                11:0    1  10.2G  0 rom  
nvme0n1           259:0    0    20G  0 disk 

字段信息解读：
NAME 		#设备名称
MAJ:MIN 	#主设备号:次设备号
RM 			#是否是可移动设备，0代表不是，1代表是
SIZE 		#设备容量大小
RO 			#是否是只读设备，0代表不是，1代表是
TYPE 		#设备类型
MOUNTPOINT 	#挂载点
```

```
lsblk -f		#显示设备所关联的文件系统
lsblk -p		#显示设备全路径
```

### 1.2.4fdisk分区

```
	fdisk是一个创建和维护分区表的程序，它兼容DOS类型的分区表、BSD或者SUN类型的磁盘列表。它常被用于创建、删除、调整磁盘分区，以及更改分区类型等操作。
 	fdisk主要使用传统的MBR（主引导记录）分区表格式。MBR分区表有一些限制，例如最多支持4个主分区或3个主分区和1个扩展分区。
```

```
格式
	fdisk [options] <disk>
常用选项
 	-l|--list 					#显示
 	-lo 						#仅显示特定的列信息
一般选项
    -b|--sector-size <size> 	#指定扇区大小，默认512字节
    -L|--color[=color]          #显示时是否添加颜色(auto|always|never)默认启用颜色
    -o|--output <list> 			#只显示指定列
    -u|--units[=<unit>]         #设置显示单位 cylinders|sectors，默认sectors
    -s|--getsz 					#显示设备有多少个扇区
    -b|--bytes N                #以指定的字节大小来计算扇区数量
    -t|--type type             	#只显示指定类型的分区表
    -C|--cylinders N       		#指定柱面数
    -H|--heads N           		#指定磁头数
    -S|--sectors N         		#指定每条磁道的扇区数
```

fdisk 常见子命令

```
常用子命令
p: 输出分区列表 		n: 创建新分区 			w: 保存并退出
其他子命令
t: 更改分区类型 		d: 删除分区 			v: 校验分区
u: 转换单位 		q: 不保存并退出 			x: 高级功能(专家模式)
```

```
fdisk 			# 管理MBR分区
gdisk 			# 管理GPT分区
parted 			# 高级分区操作，可以是交互或非交互方式
partprobe		# 我们对磁盘设置过之后，信息没有同步到内存，这条命令就是同步信息的作用
 				# 重新设置内存中的内核分区表版本，适合于除了CentOS 6 以外的其它版本5，7，8
 				# 其实对于目前的8 和 9 ，基本上都不要做这一步了，如果没有的话，执行一遍即可
```

### 1.2.5fdisk创建/管理分区

```
fdisk /dev/sdb
```

```
常用子命令
p: 输出分区列表 		n: 创建新分区 			w: 保存并退出		m：查看帮助
其他子命令
t: 更改分区标识 		d: 删除分区 			v: 校验分区
u: 转换单位 		q: 不保存并退出 			x: 高级功能(专家模式)
```

```
命令解读：
 	d\n -- 代表输入d后按Enter
 	\n  -- 直接按Enter，代表使用默认值
echo -e 'd\n\nd\n\nd\n\nw' | fdisk /dev/sdb
				#删除三个分区后，保存分区效果
echo -e 'n\np\n\n\n+10G\nw' | fdisk /dev/sdb
				#创建一个10G的分区
```

### 1.2.6gdisk创建管理分区

```
	gdisk是GPT（GUID分区表）磁盘分区工具 - "GPT fdisk"，适用于使用GPT分区表的系统。GPT是一种新一代的磁盘分区方案，可以解决MBR的一些限制。与MBR相比，GPT支持更大的磁盘容量、更多的分区、更可靠的数据恢复等特性。
 	gdisk提供了类似于fdisk的功能，但是针对GPT分区表进行操作。
```

```
格式
	gdisk [ -l ] device
	
常用子命令
    n       #新建分区
    c       #修改分区名
    o       #创建新的分区表
    w       #保存退出
其他子命令
    b       #备份分区表到指定文件
    d       #删除分区
    i       #显示分区详细信息
    l       #列出所有分区类型
    p       #查看分区
    q       #退出
    r       #恢复和转换选项，非专业人士勿用
    s       #排序
    t       #修改分区类型，默认 8300,表示普通分区
    v       #检测硬盘是否有问题
    x       #额外功能，专家模式
    ?       #显示帮助
```

```
	原则上来说，对于gdisk分区来说，最好找一个没有被分区的磁盘来进行操作，因为磁盘会有残留信息。
	直接使用 fdisk的 d 属性删除所有的分区，这种方式，虽然能够实现磁盘格式化的方式，但是还是会残留一些基本的信息，像这种格式化方式，我们称为 "低级格式化"，简称 "低格"。
	新旧磁盘，还是有一些信息区别的，主要体现在 磁盘标识信息上面
```

```
常用子命令
p: 输出分区列表 		n: 创建新分区 			w: 保存并退出		m：查看帮助
其他子命令
t: 更改分区标识 		d: 删除分区 			 q:不保存退出
```

### 1.2.7 总结

```
物理设备——>分区——>文件系统格式化——>存储空间的操作（挂载）
```

![image-20241107141202724](5day-png\8分区.png)

![image-20241107141335988](5day-png\8分区2.png)

```
MBR:
	分区数量有限制
	支持磁盘寻址大小2TB左右
	默认情况下，非ubuntu的系统，采用的 mbr的分区方式
GPT:
	主分区数量超过了4个分区的限制
	支持硬盘寻址大小，超出了 2T的限制‘
	默认情况下，ubuntu采用是 gpt 分区方式
	
关于 MBR 和 GPT 这两种分区方式，我们重点关心 第一扇区的位置结构
对于其他的位置扇区，主要就是数据存储
	第一扇区结构（MBR的扇区 0）：
	MBR 的第一扇区结构通常为 512 字节，其中包括以下几个部分：
		引导程序（Bootloader）（446 字节）：
			引导程序通常是小型的机器代码程序，它的任务是帮助启动操作系统。
			在计算机启动时，BIOS 会将 MBR 的内容加载到内存中并执行它。
			引导程序会执行一些初始化操作，并决定从哪个分区加载操作系统。
		分区表（Partition Table）（64 字节）：
			分区表记录了硬盘上的分区信息。MBR 支持最多 4 个主分区或者 3 个主分区加 1 个扩展分区。
			每个分区表项占 16 字节，总共有 4 个分区表项，因此分区表的总大小为 64 字节。
			每个分区表项包含：分区的起始扇区、分区类型、大小等信息。
		魔术数字（Magic Number）（2 字节）：
		这是一个固定的数字 0x55AA，位于 MBR 的最后 2 字节。它是 MBR 的“签名”，表示该分区表有效。如果这两个字节的值不正确，系统就无法识别该分区表。

MBR 第一扇区的结构概述：
	引导程序（446 字节）
	分区表（64 字节）
	魔术数字（2 字节）
```

![image-20241107142157185](5day-png\8分区3.png)

```
问题：如果我把MBR的第一个扇区里面的 分区给 搞坏了，立刻重启主机
    如何调整 系统的启动方式
    	1 打开电源，直接进入到BIOS
		2 找到Boot
		3 光标移动到 CD-ROM
		4 shift +  上移到第一位
		5 按Esc 进入到Exit选项
		6 按保存save
```

GPT分区

```
1 主分区数量，可以超过4个
2 磁盘的容量，可以超过2T
3 分区的标识 gpt
```

fdisk/dgisk创建分区

```
进入分区操作
    创建分区   	n
    选择分区类型   p主 | e扩展
    分区号     默认1，而且是递增
    起始扇区号
    结束扇区号
    检查      p
    保存      w

删除分区
    删除分区  d
    选择要删除的分区编号   4 {默认是倒序}
    注意：
    	删除中间分区的时候
    	分区号，会自动调整
    	
更改分区类型标识：
	更改标识  t
	选择分区  4
	确定分区标识号   86
	保存        w
	
注意：
    对于已经使用 NBR做过分区的磁盘，即使将所有分区移除，还是会遗留之前分区的信息
```

## 1.3文件系统

### 1.3.1文件系统基础

文件系统的组成：

```
- 内核中的模块：ext4, xfs, vfat 
- Linux的虚拟文件系统：VFS 
- 用户空间的管理工具：mkfs.ext4, mkfs.xfs,mkfs.vfat
```

查看当前内核的文件系统信息查看

```
ls /lib/modules/$(uname -r)/kernel/fs
```

查看当前系统可用的文件系统

```
cat /proc/filesystems
```

- 在Rocky linux9 和 Ubuntu24.04 中，执行 touch abc.txt 文件，分别调用的哪个文件系统？

```
Rocky Linux 9 默认在 XFS 文件系统上创建文件。
Ubuntu 会在 ext4 文件系统上创建文件。
```

linux文件系统

```
EXT3:
    - 最多只能支持32TB的文件系统和2TB的文件，实际只能容纳2TB的文件系统和16GB的文件
    - Ext3目前只支持32000个子目录
    - Ext3文件系统使用32位空间记录块数量和 inode数量
    - 当数据写入到Ext3文件系统中时，Ext3的数据块分配器每次只能分配一个4KB的块
```

```
EXT4
    - EXT4是Linux系统下的日志文件系统，是EXT3文件系统的后继版本
    - Ext4的文件系统容量达到1EB，而支持单个文件则达到16TB
    - 理论上支持无限数量的子目录
    - Ext4文件系统使用64位空间记录块数量和 inode数量
    - Ext4的多块分配器支持一次调用分配多个数据块
    - 修复速度更快
```

```
XFS
    - 根据所记录的日志在很短的时间内迅速恢复磁盘文件内容
    - 用优化算法，日志记录对整体文件操作影响非常小
    - 是一个全64-bit的文件系统，最大可以支持8EB的文件系统，而支持单个文件则达到8EB 
    - 能以接近裸设备I/O的性能存储数据
```

| ext4    | ext 文件系统的最新版。有很多新的特性，包括纳秒级时间戳、巨型文件(16TB)、最大1EB的文件系统，以及速度的提升 |
| ------- | ------------------------------------------------------------ |
| xfs     | SGI，支持最大8EB的文件系统                                   |
| swap    | 交换分区专用的文件系统                                       |
| iso9660 | 光盘文件系统                                                 |



### 1.3.2管理操作mkfs、mke2fs、blkid、e2lable、dumpe2fs、xfs_info

mkfs[必会] 格式化文件系统

```
格式
	mkfs [options] [-t <type>] [fs-options] <device> [<size>]
选项
	-t|--type=model 	#指定文件系统类型 (ext2|ext3|ext4|xfs)，默认ext2
 						#等同于 mkfs.type_model
一般选项
    -b               	#指定块 block 大小 (1024|2048|4096)
    -L LABEL 			#设置卷标
    -V|--verbose     	#显示创建过程
    -j 					#同 -t ext3
    -i N  				#为数据空间中每多少个字节创建一个inode；不应该小于block大小
    -N N 				#指定分区中创建多少个inode
    -I N               	#一个inode记录占用的磁盘空间大小，128---4096
    -m N 				#默认5%,为管理人员预留空间占总空间的百分比
    -O FEATURE[,...] 	#启用指定特性
    -O ^FEATURE 		#关闭指定特性
```

mke2fs：ext系列文件系统专用管理工具

```
格式
	mke2fs [OPTION]... DEVICE
选项
	-t					#指定文件系统类型 {ext2|ext3|ext4|xfs}
其他选项
    -b 					#指定块大小{1024|2048|4096} 
    -L LABEL 			#设置卷标
    -j 					#同 -t ext3，mkfs.ext3|mkfs -t ext3|mke2fs -j|mke2fs -t ext3
    -i N 				#为数据空间中每多少个字节创建一个inode 不应该小于block大小
    -N N 				#指定分区中创建多少个inode
    -I N 				#一个inode记录占用的磁盘空间大小，128---4096
    -m N 				#默认5%,为管理人员预留空间占总空间的百分比
    -O FEATURE[,...] 	#启用指定特性
    -O ^FEATURE 		#关闭指定特性
```

blkid [必会] 查看块设备属性信息（和文件系统关联的）

```
命令格式：
 	blkid [OPTION]... [DEVICE]
常用选项
    -U UUID 			#根据指定的UUID来查找对应的设备
    -L LABEL 			#根据指定的LABEL来查找对应的设备
```

e2label 管理ext系列文件系统的LABEL（为分区做别名）

```
命令格式：
 e2label DEVICE [LABEL]
```



分区状态查看

dumpe2fs 显示ext文件系统信息，将磁盘块分组管理

```
命令格式：
 dumpe2fs [OPTION]... [DEVICE]
```

xfs_info 显示已挂载的 xfs 文件系统信息

```
命令格式：
 xfs_info mountpoint|devname
```

### 1.3.3挂载基础mount、umount

```
在Linux系统中，进行文件系统挂载操作时，主要使用的命令包括mount和umount等，
```

挂载文件系统命令解读

```
格式
	mount [-t 文件系统类型] [-o 特殊选项] 源文件系统 目标挂载点
选项
 	-a：挂载/etc/fstab文件中列出的所有文件系统。
 	-t：指定文件系统类型，如ext4、ntfs、iso9660等。
    -o：指定挂载选项，如读写权限、访问控制等。
    -l：列出系统中当前挂载的所有文件系统
    源文件系统：要挂载的设备文件的路径或设备标识符。
    	目标挂载点：将文件系统挂载到的目录。
   			注意：挂载点目录必须事先存在，建议使用空目录
   	其他选项：
 	-B|--bind 源目录 目标目录   	用于将一个目录挂载到另一个目录，实现目录的共享或重定向。
 	--source device       		指明源(路径、标签、uuid)
 	-T|--fstab path     		指定写文件，默认 /etc/fstab
 	-r|--read-only         		以只读方式挂载文件系统(同 -o ro)
```

```
-o选项值
 	async 				#异步模式,内存更改时,先写入buffer,过段时间再写到磁盘，效率高，但不安全
    sync   				#同步模式,内存更改时，同时写磁盘，安全，但效率低下
    atime/noatime 		#包含目录和文件
    diratime/nodiratime #目录的访问时间戳
    auto/noauto 		#是否支持开机自动挂载，是否支持-a选项
    exec/noexec 		#是否支持将文件系统上运行应用程序
    dev/nodev 			#是否支持在此文件系统上使用设备文件
    suid/nosuid 		#是否支持suid和sgid权限
    remount 			#重新挂载
    ro/rw 				#只读/读写   
    user/nouser 		#是否允许普通用户挂载此设备，/etc/fstab使用
    acl/noacl 			#启用此文件系统上的acl功能
    loop 				#使用loop设备
    _netdev   			#当网络可用时才对网络资源进行挂载，如：NFS文件系统
    defaults 			#相当于rw, suid, dev, exec, auto, nouser, async
```

```
--source 选项值
   	-L|--label label     	#同 LABEL=label
   	-U|--uuid uuid       	#同 UUID=uuid
    LABEL=label           	#用label值指定设备
    UUID=uuid             	#用uuid值指定设备
    PARTLABEL=label       	#按PARTLABEL值指定设备
    PARTUUID=uuid         	#按PARTUUID值指定设备
    device               	#按路径指定设备
    directory             	#绑定式挂载的挂载点(参阅 --bind/rbind)
    file                 	#用于设置回环设备的常规文件
```

卸载已挂载的文件系统命令解读

```
格式：
 	umount [-f] [-l] [-n] 挂载点
 
常见选项：
 	-f：强制卸载。
    -l：延迟卸载，直到文件系统不再被使用。
    -n：不将卸载操作写入系统日志。
    
注意：
 	卸载时，可使用设备，也可以使用挂载点
```

挂载规则

```
- 一个挂载点同一时间只能挂载一个设备
- 一个挂载点同一时间挂载了多个设备，只能看到最后一个设备的数据，其它设备上的数据将被隐藏
- 一个设备可以同时挂载到多个挂载点
- 通常挂载点一般是已存在空的目录
```

### 1.3.4挂载信息

查看文件系统挂载信息命令解读

```
查看磁盘格式化的文件系统信息
lsblk -f 磁盘设备名
查看所有已挂载的文件系统信息
df 或者 df -Th
查看已挂载的所有文件系统
mount
查看挂载点的状态
findmnt <磁盘设备名> <挂载点>
```

通过文件的方式查看文件系统的挂载状态

```
通过查看/etc/mtab文件显示当前已挂载的所有设备
cat /etc/mtab
查看内核追踪到的已挂载的所有设备
cat /proc/mounts
```

文件系统的操作进程管理

```
查看正在访问指定文件系统的进程
lsof 挂载点
fuser -v 挂载点
终止所有在正访问指定的文件系统的进程
fuser -km 挂载点  
```

### 1.3.5持久挂载

```
1 打开/etc/fstab文件
2 添加挂载信息
3 保存并关闭文件
4 验证挂载配置
```

```
/dev/sdb1 /opt  ext4  defaults  0 0 
```

### 1.3.6异常修复

fsck: File System Check 命令解读

```
命令格式：
 	fsck [options] -- [fs-options] [<filesystem> ...]
常用选项
    -a 		#自动修复
    -r 		#交互式修复错误
```

e2fsck： ext系列文件专用的检测修复工具

```
命令格式：
 e2fsck [options] -- [fs-options] [<filesystem> ...]
常用选项
    -y 				#自动回答为yes
    -f 				#强制修复
    -p 				#自动进行安全的修复文件系统问题
```

xfs_repair：xfs文件系统专用检测修复工具

```
命令格式：
 xfs_repair [options] device
常用选项
    -f 		#修复文件，而设备
    -n 		#只检查
    -d 		#允许修复只读的挂载设备，
   			#在单用户下修复 / 时使用，然后立即reboot
```

### 1.3.7总结

```
个人认知小技巧：
    文件系统不能直接在 物理设备上
        必须要先进行分区 
  
ext4   		ext 文件系统的最新版。有很多新的特性，包括纳秒级时间戳、巨型文件(16TB)、最大1EB的文件系统，以及速度的提升
xfs     	SGI，支持最大8EB的文件系统
swap    	交换分区专用的文件系统(从物理磁盘里面，划分一块区域，假装是内存，给os来使用)
iso9660 	光盘文件系统


个人小技巧：
    格式化命令
        mkfs.ext4 /dev/sdb?
        mkfs.xfs /dev/nvme0n?
        
定位： 将格式化后的磁盘分区，交给文件系统路径，然后进行使用

关于mount，只需要记住
    mount /dev/xxx  /mount_point
    -t 的选项能力：
    如果涉及到网络文件系统挂载的时候，可以去指定
        前提，你需要提前知道，是什么类型的网络文件系统
        但是，mount 挂载的时候，会自动识别文件系统类型
        
        检查挂载的效果
    		mount
    		lsblk -f
    		
关联的动作就是 挂载
去取消关联的动作 就是  卸载
挂载后，目录里面的内容，全部被覆盖

查看已挂载的文件信息
	个人实践小技巧
    mount | grep xxx
    
如何实现持久挂载
    1 开机时候定制一个 挂载脚本
            /etc/profile.d/mount.sh
    2 开机自动挂载配置文件
            /etc/fstab
    
    fstab的 属性格式：
	1 挂载设备
	2 挂载目录
	3 文件系统
	4 挂载选项 - 能够数据操作  default
	5 是否备份  0
	6 是否挂载前检测   0
	
问题：
    我进入到挂载目录里面，操作过文件后，能不能 直接 卸载？
    不能
    

1 检测文件系统是否正常
2 遇到异常的文件系统，怎么修复
   e2fsck  /dev/sdx

```

## 1.4RAID

### 1.4.1磁盘列阵

RAID0

```
工作原理
	它将数据分成小块（称为“条带”），然后将这些条带交替地写入两个或更多的磁盘中。这样，数据的读取和写入操作可以并行进行，从而提升了性能。
特点
	RAID 0既没有冗余功能，也不具备容错能力，如果一个磁盘（物理）损坏，所有数据都会丢失
```

![image-20241109165246211](5day-png\rid1.png)

RAID1

```
工作原理
	RAID 1 的核心工作原理是数据镜像。它通过将相同的数据写入到两个或更多的磁盘上，每个磁盘上都有一份相同的数据副本（镜像）。当一个磁盘发生故障时，系统可以从另一个磁盘上读取相同的数据，确保数据不丢失。
特点
	RAID 1提供了最高的数据安全性，在一些多线程操作系统中能有很好的读取速度，理论上读取速度等于硬盘数量的倍数，但磁盘利用率只有50%，且写入速度相对较慢。它适用于保存关键性重要数据的场合。
```



RAID5

```
工作原理
	RAID 5 通过将数据和奇偶校验信息分布到多个磁盘上来实现冗余保护。奇偶校验是通过逻辑计算将数据的一部分生成奇偶校验信息，并将其存储在阵列中的不同硬盘上，这样即使一个磁盘发生故障，也能通过其他磁盘上的数据和奇偶校验信息来恢复丢失的数据。
特点
	RAID 5可以容错一个磁盘的故障，同时提供较高的读写速度和磁盘利用率。它是目前综合性能最佳的数据保护解决方案之一。
```

![image-20241109165415430](5day-png\rid6.png)

RAID01

```
	RAID-01也被称为RAID 0+1，是先将多个硬盘组合成RAID 0阵列，然后再对这些RAID 0阵列进行镜像。这种结构相对复杂，且在实际应用中较少见。
 	RAID-01通过RAID 0阵列实现了数据的条带化存储，从而提高了数据传输速度。然而，由于镜像操作的存在，其整体性能可能略低于纯RAID 0阵列。
```



RAID10

```
RAID-10也被称为RAID 1+0，是RAID 1与RAID 0的结合体。它首先创建多个RAID 1镜像对，然后将
这些镜像对组合成一个RAID 0阵列。这种结构既提供了RAID 0的高性能，又具备了RAID 1的数据冗余和容
错能力。
 由于采用了RAID 0的条带化技术，RAID-10能够并行读写多个磁盘，从而显著提高数据传输速度。
```

![image-20241109165219549](5day-png\8RID10.png)

### 1.4.2软RID

```
mdadm是multiple devices admin的简称，它是Linux下的一款标准的软件RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）管理工具。
```

```
mdadm能够执行创建、管理、监控RAID设备的任务，它使用Linux中的md驱动。具体来说，mdadm具备
以下基本功能：
    创建（create）RAID设备。 	构建（build）RAID设备。    	组装（assemble）RAID设备。
    扩展（grow）RAID设备。 	管理（manage）RAID设备。   	监控（monitor）RAID设备。
```

```
格式
	mdadm [mode] <raiddevice> [options] <块设备>
常用动作
    -C|--create 		#创建
    -A|--assemble 		#装配
    -F|--monitor 		#监控
    -D|--detail 		#显示raid的详细信息
    -f 					#标记指定磁盘为损坏
    -r|--remove 		#移除磁盘
    -a|--add 			#添加磁盘
 	--grow 				# 用于调整RAID设备的参数，如成员盘个数、空间大小等。
 	-S|--stop 			#关于raid设备
常用选项
     -n N 				#使用N个块设备来创建此RAID
     -l N 				#指明要创建的RAID的级别
     -a {yes|no} 		#自动创建目标RAID设备的设备文件
     -c CHUNK_SIZE 		#指明块大小,单位k
     -x N 				#指明空闲盘的个数
```

## 1.5lvm

### 1.5.1lvm基础

```
物理存储介质：
 指系统的存储设备，如硬盘，是存储系统的最低层存储单元。
-----
PV（Physical Volume，物理卷）：
    是LVM存储管理的最底层，可以是整个物理硬盘或实际物理硬盘上的分区。
    物理卷在加入LVM之前需要经过特殊处理，以便LVM能够识别和管理。
VG（Volume Group，卷组）：
    是建立在物理卷之上的一个逻辑层，它包含了一个或多个物理卷。
    卷组将多个物理卷组合在一起，形成一个可管理的单元，类似于非LVM系统中的物理硬盘。
LV（Logical Volume，逻辑卷）：
    是建立在卷组之上的一个逻辑层，它类似于非LVM系统中的硬盘分区。
    逻辑卷可以在其上建立文件系统，并挂载到不同的挂载点，用于存储数据。
-----
PE（Physical Extent，物理区域）：
    是物理卷中可用于分配的最小存储单元。PE的大小是可配置的，默认为4MB。
    在建立卷组时，物理区域的大小会被指定，并且一旦确定就不能更改。
    同一卷组中的所有物理卷的物理区域大小必须一致。
LE（Logical Extent，逻辑区域）：
    是逻辑卷中可用于分配的最小存储单元。
    逻辑区域的大小取决于逻辑卷所在卷组中的物理区域的大小，即一个LE对应一个PE。
```

关联关系

```
PE与PV的关系：
    PE是物理卷（PV）中可用于分配的最小存储单元。
    每个物理卷都会被划分为多个PE，这些PE是LVM进行存储分配的基本单位。
    
LE与LV的关系：
    LE是逻辑卷（LV）中可用于分配的最小存储单元。
    每个逻辑卷都会被划分为多个LE，这些LE与卷组中的PE一一对应。
    
VG与PV的关系：
    卷组（VG）建立在物理卷（PV）之上，一个卷组可以包含多个物理卷。
    物理卷在加入卷组之前需要被初始化为LVM物理卷。
    
LV与VG的关系：
    逻辑卷（LV）建立在卷组（VG）之上，卷组中的未分配空间可以用于创建新的逻辑卷。
    逻辑卷在创建后可以动态地扩展和缩小空间，以适应不同的存储需求。
```

整体关系

```
五个术语相互关联
 	PE和LE是LVM进行存储分配的基本单位，它们分别位于物理层和逻辑层。
 	PV是LVM存储管理的最底层，VG是建立在PV之上的一个逻辑层，而LV则是建立在VG之上的另一个逻辑层。
 	这些层次结构共同构成了LVM存储管理的框架，使得LVM能够灵活地管理存储资源。
综上所述：
 	PE、LE、PV、VG和LV在LVM中扮演着不同的角色，它们之间存在密切的关系和相互作用。这些概念和层次结构共同构成了LVM存储管理的核心，使得LVM能够高效地管理存储资源并满足不同的存储需求。
```

```
Rocky系统
 yum install -y lvm2
Ubuntu系统
 apt install -y lvm2
```

### 1.5.2创建实践

```
拿到一个磁盘——>分区——>格式化——>创建pv——>创建vg——>创建lv——>格式化lv——>挂载
```

```
物理卷信息查看命令：
    pvs 			#简要pv信息显示
    pvdisplay 		#显示详细信息
    
创建PV命令：
 	pvcreate /dev/DEVICE 		#创建物理卷
```

```
卷组信息查看命令：
 	vgs 			#简要vg信息显示
 	vgdisplay 		#显示详细信息
创建VG命令：
 	vgcreate [-s Size ] vgname pv1 [pv2...] 		# 创建VG
 					# -s 指定PE大小，数字加单位，单位为 k|K|m|M|g|G|t|T|p|P|e|E
 					
 	vgcreate -s 16M testvg /dev/sdb1 /dev/sdc1
 				#将两个物理卷，创建一个vg一个PE大小为16M的vg
```

```
逻辑卷信息查看命令
 	lvs 			#简要lv信息显示
 	Lvdisplay 		#显示详细信息
 	lvscan 			#查看lv的具体名称路径
创建LV命令：
 	lvcreate {-L N[mMgGtT]|-l N} -n NAME VolumeGroup
 选项参数：
        -L|--size N[mMgGtT] 		#指定大小 
        -l|--extents N 				#指定PE个数,也可用百分比
        -n Name 					#逻辑卷名称
        
    lvcreate -l 100 -n lv1 testvg	
    				#从 testvg 中创建lv1,大小为 100个PE
    lvcreate -L 5G -n lv2 testvg
    				#创建lv2，大小为5G
   	lvcreate -l 20%free -n lv3 testvg
   					#创建lv3,大小为剩下可用PE数量的 20%
   	lvcreate -l 10%VG -n lv4 testvg
    				#创建lv4,大小为指定vg的10%
```

### 1.5.3管理实践

```
管理LVM：
 可以使用lvextend命令扩展逻辑卷的大小，使用lvreduce命令缩小逻辑卷的大小（但需要注意数据丢
失的风险）。此外，还可以使用lvscan、lvdisplay等命令查看逻辑卷的信息。
```

```
扩展逻辑卷:
 要先保证卷组上还有空间
 扩展方式1:
 	先扩展逻辑卷 
 		lvextend -L [+]N[mMgGtT] /dev/VG_NAME/LV_NAME
 	再扩容文件系统 
 		resize2fs /dev/VG_NAME/LV_NAME
 		xfs_growfs MOUNTPOINT
 	扩展方式2: 一步实现容量和文件系统的扩展
 		lvresize -r -l +100%FREE /dev/VG_NAME/LV_NAME
```

```
缩减逻辑卷：
 缩减有数据损坏的风险，建议先备份再缩减，不支持在线缩减，要先取消挂载，xfs文件系统不支持缩减
 1 取消挂载
 umount /dev/VG_NAME/LV_NAME
 2 文件系统检测,e2fsck可写成fsck
 e2fsck -f /dev/VG_NAME/LV_NAME
 3 缩减文件系统到指定大小
 resize2fs /dev/VG_NAME/LV_NAME N[mMgGtT]
 4 缩减逻辑卷
 lvreduce -L [-] N[mMgGtT] /dev/VG_NAME/LV_NAME
 5 重新挂载
 mount /dev/VG_NAME/LV_NAME mountpoint
 
注意：
 3+4 可以简写为 lvreduce  -L N[mMgGtT] -r /dev/VG_NAME/LV_NAME
```

```
管理卷组命令：
    vgextend vgname pv1 [pv2...] 		#往卷组中添加物理卷
    vgreduce vgname pv1 [pv2...] 		#从卷组中移除物理卷
```

```
扩展逻辑卷
 	lvextend {-L N[mMgGtT]|-l N} LV_NAME
        常用选项
        -L|--size [+]Size[mMgGtT] 			#N个单位大小，也可写成+10M
        -l|--extents [+]Number[PERCENT] 	#N个PE，也可以写成+10，表示在原基础上加10个PE大小
       										#+100%free 表示把剩下空间都用完
        -r|--resizefs 						#自动重置文件系统大小
同步文件系统
 	针对ext：resize2fs /dev/VG_NAME/LV_NAME
 	针对xfs：xfs_growfs MOUNTPOINT
```

```
缩减逻辑卷
 lvreduce {-L N[mMgGtT]|-l N} LV_NAME
        常用选项
        -L|--size [-]Size[mMgGtT] 			#N个单位大小，也可写成-10M
        -l|--extents [-]Number[PERCENT] 	#N个PE，也可以写成-10，表示在原基础上减10个PE大小
```

实践

扩展逻辑卷实践

```
向testvg里面增加新的pv
vgextend testvg /dev/sdd1

使用lvextend命令扩展逻辑卷的大小，增加1G
lvextend -L +1G /dev/testvg/lv1
扩容文件系统
resize2fs /dev/testvg/lv1

一步到位扩容所有的剩余空间
lvresize -r -l +100%FREE /dev/testvg/lv1
```

缩小逻辑卷实践

```
取消挂载
umount /dev/testvg/lv1
文件系统检测,e2fsck可写成fsck
e2fsck -f /dev/testvg/lv1
缩减文件系统到指定大小
resize2fs /dev/testvg/lv1 3G
缩减逻辑卷
lvreduce -L 3G /dev/testvg/lv1
重新挂载
mount /dev/testvg/lv1 /mount/lvm

精简版
umount /dev/testvg/lv1
lvreduce  -L 1G -r /dev/testvg/lv1
mount /dev/testvg/lv1 /mount/lvm
```

在不影响应用运行的情况下，将数据迁移到新盘

```
1、为新盘创建物理卷（PV）
pvcreate /dev/sdb3

2、将新物理卷加入现有卷组（VG）
vgextend testvg /dev/sdb3
lvextend -L +2G /dev/testvg/lv1 

3、使用 pvmove 迁移数据
pvmove /dev/sdb1 /dev/sdb3

4、从卷组中移除旧盘
vgreduce testvg /dev/sdb1

5、释放旧盘
pvremove /dev/sdb1
```

### 1.5.4删除实践

```
删除LVM：
 	在删除LVM时，需要注意先解除挂载再删除逻辑卷，先删除逻辑卷再删除卷组，最后删除物理卷。可以使用lvremove命令删除逻辑卷，使用vgremove命令删除卷组，使用pvremove命令删除物理卷。

删除PV命令
 	pvremove /dev/DEVICE
 
删除卷组命令
 	vgremove vgname # 删除vg之前，要先把对应的 pv 解除绑定 (pvmove)
 
删除lv命令
 	lvremove /dev/VG_NAME/LV_NAME
```

实践

```
卸载逻辑卷：使用umount命令卸载逻辑卷
umount /mount/lvm
删除逻辑卷：使用lvremove命令删除逻辑卷。
lvremove /dev/testvg/lv1
删除卷组：使用vgremove命令删除卷组 -- 会提示是否要删除不用的lv对象
vgremove testvg
删除物理卷：使用pvremove命令删除物理卷。
pvremove /dev/sdb1 /dev/sdc1 /dev/sdd1
```

### 1.5.5lvm快照

原理

```
	在生成快照时，并不会立即复制原逻辑卷中的所有数据，而是分配一定的空间给快照。当原逻辑卷中的数据发生变化时，变化的数据会被复制到快照区域，而未变化的数据则继续由原逻辑卷和快照共享。
建立快照的卷大小小于等于原始逻辑卷，也可以使用lvextend扩展快照
```

```
节省空间：由于快照仅存储变化的数据，因此相对于完全备份，快照可以大大节省存储空间。
快速创建：快照创建过程迅速，不会对系统性能产生显著影响。
数据恢复：通过快照，可以轻松地将数据恢复到创建快照时的状态，这对于数据恢复和灾难恢复非常重要。
一次性使用：快照通常是一次性使用的，一旦还原，快照就会失效并被删除。
```

使用流程

```
1 创建快照：
 	使用lvcreate命令并添加-s参数来创建一个快照。同时，可以使用-L参数指定快照的大小，以及-n参数指定快照的名称。
2 挂载快照：
 	将快照挂载到一个空目录上，以便访问快照中的数据。快照通常以只读方式挂载。
3 备份数据：
 	在快照挂载后，可以使用常规的备份工具（如rsync、tar等）对快照中的数据进行备份。
4 恢复数据（可选）：
 	如果需要从快照恢复数据，可以先卸载原始逻辑卷，然后使用lvconvert --merge命令将快照合并到主逻辑卷中。这将把快照时的数据状态应用到主逻辑卷上。
5 删除快照：
 	完成备份或数据恢复后，可以使用lvremove命令删除快照。
```

```
快照大小：
 	在创建快照时，需要评估原逻辑卷中可能发生变化的数据量，并据此设置快照的大小。如果快照大小设置过小，可能无法容纳所有变化的数据，导致快照失效。
 
快照与卷组：
 	快照和原逻辑卷必须位于同一个卷组（VG）中，因为快照需要共享原逻辑卷的物理存储区域（PE）。
 
快照状态：
 	可以通过lvscan命令查看系统中逻辑卷和快照的状态。如果快照处于inactive状态，可能是因为原逻辑卷中的数据变化量超过了快照的大小限制。
```

制作快照

```
为逻辑卷创建快照,创建之前要保证 vg 上有足够的空间
#-s 表示快照
#-L 100M 表示大小，大小取决于你要修改多少文件
#-p r 表示该卷只读
lvcreate -n lv1_snapshot -s -L 100M -p r /dev/testvg/lv1
```

还原快照

```
取消所有挂载
umount /mount/lvm
umount /mount/lvm_snapshot
从快照中恢复数据
lvconvert --merge /dev/testvg/lv1_snapshot
挂载lv之后，查看效果
mount /dev/testvg/lv1 /mount/lvm
```

