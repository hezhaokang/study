# 1、shell基础

## 1.1shell简介

简介：shell就是在操作系统和应用程序之间的一个命令翻译工具

## 1.2shell脚本实践

当可执行的Linux命令或语句不在命令行状态下执行，而是通过一个文件执行时，我们称文件为shell脚本。

- 脚本注释

```
单行注释：
	除了首行的#不是注释外，其他所有行内容，只要首个字符是#,那么就表示该行是注释
多行注释：
	多行注释有两种方法：:<<! ... !  和 :<<字符 ... 字符	
```

​	自动获取网络信息脚本

```
#!/bin/bash
#获取IP地址信息
ip a show ens33 | awk 'NR==3{print $2}' | awk -F'/' '{print $1}' | xargs echo "IP:"

#获取掩码信息
ip a show ens33 | awk 'NR==3{print $2}' | awk -F'/' '{print $2}' | xargs echo "Network:"

#获取广播地址信息
ip a show ens33 | awk 'NR==3{print $4}'| xargs echo "Broadcast:"

#获取mac地址信息
ip a show ens33 | awk 'NR==2{print $2}' | xargs echo "MAC Address:"
```

## 1.3 脚本执行

```
方法1：
 bash /path/to/script-name 或 /bin/bash /path/to/script-name （强烈推荐使用）
 
方法2：
 /path/to/script-name 或 ./script-name （当前路径下执行脚本）
 
方法3：
 source script-name 或 . script-name （注意“.“点号）
 
方法1变种：
 cat /path/to/script-name | bash
 bash /path/to/script-name
```

```
脚本执行说明
1、脚本文件本身没有可执行权限或者脚本首行没有命令解释器时使用的方法，我们推荐用bash执行。
 使用频率：☆☆☆☆☆
2、脚本文件具有可执行权限时使用。
 使用频率：☆☆☆☆
3、使用source或者.点号，加载shell脚本文件内容，使shell脚本内容环境和当前用户环境一致。
    使用频率：☆☆☆
    使用场景：环境一致性
```

## 1.4脚本调试

```
-n 检查脚本中的语法错误
-v 先显示脚本所有内容，然后执行脚本，结果输出，如果执行遇到错误，将错误输出。
-x 将执行的每一条命令和执行结果都打印出来
```

## 1.5脚本开发规范

```
1、脚本命名要有意义，文件后缀是.sh
2、脚本文件首行是而且必须是脚本解释器
 #!/bin/bash
3、脚本文件解释器后面要有脚本的基本信息等内容
 脚本文件中尽量不用中文注释;
 尽量用英文注释，防止本机或切换系统环境后中文乱码的困扰
 常见的注释信息：脚本名称、脚本功能描述、脚本版本、脚本作者、联系方式等
4、脚本文件常见执行方式：bash 脚本名
5、脚本内容执行：从上到下，依次执行
6、代码书写优秀习惯;
    1）成对内容的一次性写出来,防止遗漏。
如：()、{}、[]、''、``、""
    2）[]中括号两端要有空格,书写时即可留出空格[    ],然后再退格书写内容。
    3）流程控制语句一次性书写完，再添加内容
7、通过缩进让代码易读;(即该有空格的地方就要有空格)
```

# 2、shell变量

## 2.1变量基础

### 2.1.1变量场景

```
所谓的数据存储，我们从三方面来理解这句话：
    1、数据保存到哪里 -- 各种媒介，CPU、内存、磁盘、磁带、网盘...
    2、数据保存的效果 -- 完整、安全、有效
    3、数据保存的单元 -- 存储空间
```

```
变量的本质其实就是 通过一个名称帮助程序快速找到内存中具体数据的地址。
	变量说白了就是指向xx值。
```

### 2.1.2变量的定义

```
变量包括三部分：
 变量名 - 不变的
 变量值 - 变化的
 赋值动作 - 变量名指向变量值
表现样式：
 变量名=变量值
```

命名规范

```
1 名称有意义
2 名称细节
 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
    中间不能有空格，可以使用下划线（_）。
    不能使用标点符号。
    不能使用bash里的关键字（可用help命令查看保留关键字）。
3 命名样式
 	大驼峰HelloWorld,每个单词的首字母是大写
 	小驼峰helloWorld,第一个单词的首字母小写，后续每个单词的首字母是大写
	下划线: Hello_World
 	大小写字母： helloworld, HELLOWORLD
 注意：
 	对于开发人员来说，他们对于变量名的规范比较多，什么类、函数、对象、属性、命名空间等都有要求
 	对于运维人员来说，记住一个词 -- 有意义。
```

变量分类

```
shell 中的变量分为三大类：
    本地变量 变量名仅仅在当前终端有效 
    全局变量 变量名在当前操作系统的所有终端都有效
    shell内置变量 shell解析器内部的一些功能参数变量
    
注意：
 	这里的变量分类的特点仅仅是从字面上来理解的，因为在实际的操作的时候，还会涉及到环境优先级的问题
 	所以生产中对于这三者的划分没有特别大的强制。
```

### 2.1.3基本操作

```
基本格式
 	$变量名
```

```
普通语法解析
	基本格式
 		变量名=变量值
注意：
 = 两侧不允许有空格
```

类型变量定义

```
命令语法
 declare 参数 变量名=变量值
参数解析：
    -i 将变量看成整数
    -r 使变量只读  readonly,==**该变量的值无法改变，并且不能unset**==
    -x 标记变量为全局变量，类似于export
    -a 指定为索引数组（普通数组）；查看普通数组
    -A 指定为关联数组；查看关联数组
注意：
 	在生产场景中，这种方法比较鸡肋，使用频率 0-20次/3年
```

变量移除

```
基本格式
	unset 变量名
```

## 2.2本地变量

### 2.2.1本地变量分类

```
所谓的本地变量就是：在当前系统的某个环境下才能生效的变量，作用范围小。
```

变量分类

```
本地变量按照变量值的生成方式包含两种：
 普通变量：
 	自定义变量名和变量值
 命令变量：
 	自定义变量名，而变量值是通过一条命令获取的
```

### 2.2.2普通变量

变量分类

```
所谓的本地变量就是：在当前系统的某个环境下才能生效的变量，作用范围小。本地变量按照变量值的生成方式包含两种：
 普通变量：
 	自定义变量名和变量值
 命令变量：
 	自定义变量名，而变量值是通过一条命令获取的
```

基本格式

| 序号   | 样式            | 要点                                                         |
| ------ | --------------- | ------------------------------------------------------------ |
| 方式一 | 变量=变量值     | 变量值必须是一个整体，中间没有特殊字符 "=" 前后不能有空格    |
| 方式二 | 变量名=‘变量值  | 原字符输出，我看到的内容，我就输出什么内容                   |
| 方式三 | 变量名=“变量值” | 如果变量值范围内，有可以解析的变量A，那么首先解析变量A，将A的结果和其他内容组合成一个整体，重新赋值给变量B |

```
习惯：
 	数字不加引号，其他默认加双引号
 	因为bash属于弱类型语言，默认会将所有内容当成字符串
```

### 2.2.3命名变量

基本格式

```
定义方式一：
 	变量名=`命令`
    注意：
    ` 是反引号
定义方式二：
 	变量名=$(命令)
```

```
执行流程：
 	1、执行 ` 或者 $() 范围内的命令
 	2、将命令执行后的结果，赋值给新的变量名
```

## 2.3全局变量

### 2.3.1基本操作

```
全局变量是什么
	全局变量就是：在当前系统的所有环境下都能生效的变量。
```

基本语法

```
查看全局环境变量
 env 			只显示全局变量,一般结合 grep 和管道符来使用
 printenv 		效果与env等同
 
 export 		查看所有的环境变量，包括声明的过程等信息，一般不用
 declare -x 	效果与export类似
```

```
定义全局变量方法一：
 	变量=值
 	export 变量
定义全局变量方法二：（最常用）
 	export 变量=值
```

### 2.3.2文件体系

变量文件

```
在linux环境中，有很多目录下的文件都可以定制一些作用范围更广的变量，这些文件或文件所在的目录有：
 作用范围在制定的用户范围：
        ~/.bashrc
        ~/.bash_profile
    作用的范围在系统范围：
        /etc/profile
        /etc/profile.d/env_file_name
```

### 2.3.3嵌套shell

```
用户登录时:
	用户登录到Linux系统后，系统将启动一个用户shell。
	在这个shell中，可以使用shell命令或声明变量，也可以创建并运行 shell脚本程序。
运行脚本时:
	运行shell脚本程序时，系统将创建一个子shell。 此时，系统中将有两个shell
		一个是登录时系统启动的shell，另一个是系统为运行脚本程序创建的shell。
	 	当一个脚本程序运行完毕，它的脚本shell将终止，可以返回到执行该脚本之前的shell。
```

```
意义解读
	从这种意义上来说，用户可以有许多 shell，每个shell都是由某个shell（称为父shell）派生的。在子shell中定义的变量只在该子shell内有效。如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的shell不能引用它，要使某个变量的值可以在其他shell中被改变，可以使用export命令对已定义的变量进行输出。
 	export命令将使系统在创建每一个新的shell时定义这个变量的一个拷贝。这个过程称之为变量输出。
```

```
当前父shell中定义变量中,分为局部变量和全局变量，不同点是：
	 - 局部变量只能作用于本父shell，子shell无法继续使用
	 - 如果使用了export将局部变量定义为全局变量，那么子shell创建的时候会继承父shell的全局变量
```

## 2.4内置变量

### 2.4.1脚本相关

脚本相关变量解析

| 序号 | 变量名 | 解析                                                         |
| ---- | ------ | ------------------------------------------------------------ |
| 1    | $0     | 获取当前执行的shell脚本文件名                                |
| 2    | $n     | 获取当前执行的shell脚本的第n个参数值，n=1..9，当n为0时表示脚本的文件名，如果n大于9就要用大括号括起来${10} |
| 3    | $#     | 获取当前shell命令行中参数的总个数                            |
| 4    | $?     | 获取执行上一个指令的返回值（0为成功，非0为失败）             |

### 2.4.2字符串相关

字符串相关的变量解析

```
字符串计数
	${#file} 获取字符串的长度
字符串截取 
 	语法为${var:pos:length}   表示对变量var从pos开始截取length个字符，pos为空标示0
    ${file:0:5} 		从0开始，截取5个字符
    ${file:5:5} 		从6开始，截取5个字符
    ${file::5} 			从0开始，截取5个字符
    ${file:0-6:3} 		从倒数第6个字符开始，截取之后的3个字符
    ${file: -4} 		返回字符串最后四个字节，-前面是"空格"
    
字符串通过下标来获取
	从0开始计数
	0第1个位置
	6第7个位置
```

### 2.4.3默认相关

基础知识

```
格式一：${变量名:-默认值}
	变量a如果有内容，那么就输出a的变量值
	变量a如果没有内容，那么就输出默认的内容
格式二：${变量名+默认值} 
	无论变量a是否有内容，都输出默认值
```

### 2.4.4其他相关

脚本相关的变量解析

| 序号 | 变量名 | 解析                                                         |
| ---- | ------ | ------------------------------------------------------------ |
| 1    | $_     | 在此之前执行的命令或脚本的第一个内容                         |
| 2    | $@     | 传给脚本的所有参数                                           |
| 3    | $*     | 是以一个单字符串显示里所有向脚本传递的参数，与位置参数不同，参数可超过9个 |
| 4    | $$     | 是脚本运行的当前进程的ID号，作用是方便以后管理它杀掉他       |
| 5    | $!     | 前一条命令进程的ID号，作用是方便以后管理它杀掉他             |

# 3、脚本交互

## 3.1基础知识

### 3.1.1shell登录解读

基础知识

```
系统级别生效配置文件
 	/etc/profile
 		系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行
    /etc/profile.d/*.sh
   		被/etc/profile文件调用，执行当前目录下所有的文件中关于shell的设置
    /etc/bashrc
   		为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。
用户级别生效配置文件
 	~/.bash_profile
 		设定用户专用的shell信息,当用户登录时,该文件仅仅执行一次
	~/.bashrc
 		该文件包含用户专用的bash信息,当登录时以及每次打开新的shell时,该文件被读取
```

```
用户退出生效配置文件
	~/.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件.
    ~/.bash_history:
   		用户登录时自动读取其中的内容并加载到内存hiatory记录中
   		logout时将内存中的history记录写入该文件中
```

shell的登陆方法

```
 交互式登录
    方法1：密码登录
        直接通过终端输入账号密码登录
        复制终端
    方法2：su 变更shell操作用户的身份
        su - 用户名
        超级用户除外，需要键入该使用者的密码。
非交互式登录
 	方法1：脚本执行
 	方法2：su 用户名
```

```
登录shell的文件生效流程
 /etc/profile.d/*.sh
 	-> /etc/profile
		-> /etc/bashrc
 			-> ~/.bashrc
 				-> ~/.bash_profile
 非登录shell的文件生效流程
 /etc/profile.d/*.sh
 	-> /etc/bashrc
		-> ~/.bashrc
注意：
	若多配置文件中设置相同的变量，则后面配置文件中变量的值会覆盖前面配置文件中同一变量的值。
```

```
su的相关参数
 	-：当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境。
    -l：同 - 的使用类似，完整切换工作环境，后面需要添加欲切换的使用者账号。
    -p：表示切换为指定用户的身份，但不改变当前的工作环境（不使用切换用户的配置文件）。
    -m：和 -p 一样；
    -c 命令：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。
```

### 3.1.2子shell基础

场景

```
	之前我们对于环境变量在多个shell环境中的应用进行了学习，那种操作量比较大。对于一些临时性的场景，我们在临时性的环境中，做一些操作，但是不希望对外部的环境造成影响，这个时候我们就涉及到了一些临时shell环境的实践。
 	关于临时shell环境的创建，我们可以借助于()方法来实现。
```

```
临时shell环境 - 启动子shell
	(命令列表)，在子shell中执行命令列表，退出子shell后,不影响后续环境操作。
临时shell环境 - 不启动子shell
	{命令列表}, 在当前shell中运行命令列表,会影响当前shell环境的后续操作。
```

()实践

```
查看子shell的pid
[root@rocky9 ~]# (echo $BASHPID; echo haha)
11661
haha
[root@rocky9 ~]# (echo $BASHPID; sleep 30)
11711
另开一个终端查看效果
[root@rocky9 ~]# pstree | grep sleep
        |-sshd-+-sshd---bash---bash---sleep
结果显示：
	在一个shell内部开启了另一个shell

子shell中，查看命令执行效果
[root@rocky9 ~]# (cd /tmp;pwd)
/tmp
[root@rocky9 ~]# pwd
/root
```

{}实践

```
root@bogon:~ $ echo $BASHPID
4442
root@bogon:~ $ { echo $BASHPID; }
4442
root@bogon:~ $ { cd /tmp; }
root@bogon:tmp $ 
```

### 3.1.3子shell实践

CA创建

umask基础

```
umask 解读
 	umask指的是文件权限默认的掩码，默认的值是022，也就是说
 		默认创建的目录是777-022=755
 		默认创建的文件是666-022-544
```

## 3.2脚本外交互

### 3.2.1read基础

```
read命令是用于从终端或者文件中读取输入的内建命令，read命令读取整行输入，每行末尾的换行符不
被读入。在read命令后面，如果没有指定变量名，读取的数据将被自动赋值给特定的变量REPLY。常用方式如
下：
	read 从标准输入读取一行并赋值给特定变量REPLY。
    read answer 从标准输入读取输入并赋值给变量answer。
    read first last 从标准输入读取内容，将第一个单词放到first中，其他内容放在last中。
    read -s passwd 从标准输入读取内容，写入passwd，不输入效果
    read -n n name 从标准输入读取内容，截取n个字符，写入name，超过n个字符，直接退出
    read -p "prompt" 打印提示，等待输入，并将输入存储在REPLY中。
    read -r line 允许输入包含反斜杠。
    read -t second 指定超时时间,默认是秒，整数
    read -d sper 指定输入信息的截止符号
```

### 3.2.2案例实践

需求

```
模拟shell终端工具的登录，功能过程如下：
 	请输入用户名: 
 	请输入密码：
 	您输入的用户名和密码是： xxx
```

```
#!/bin/bash
# 功能: 模拟shell登录
# 版本：v0.1
# 作者：wangshusen
# 联系：www.sswang.com
# 定制命令变量
OS_INFO=$(cat /etc/redhat-release)
KERNEL_INFO=$(uname -r)
OS_ARCH=$(uname -m)
HOSTNAME=$(hostname)
# 清屏
clear
# 输出提示信息
echo -e "\e[32m${OS_INFO} \e[0m"
echo -e "\e[32mKernel ${KERNEL_INFO} on an ${OS_ARCH} \e[0m"
echo "---------------------------------"
# 交互输入登陆信息
read -p "请输入用户名：" account
read -s -t30 -p "请输入登录密码：" password
echo
echo "---------------------------------"
# 输出用户输入信息
printf "您输入的用户名：\e[31m%s\e[0m您输入的密码：\e[31m%s\e[0m\n" ${account} ${password}
```

```
模拟堡垒机的登录，功能过程如下：
 	请选择要登录的主机
 	请输入用户名: 
 	使用指定的用户连接远程主机
```

```
#!/bin/bash
#功能：定制堡垒机的展示页面
#堡垒机的信息提醒
echo -e "\e[31m \t\t 欢迎使用堡垒机"

echo -e "\e[32m
-----------请选择你要登录的远程主机-----------
1: 10.0.0.11 (nginx)
2: 10.0.0.60 (tomcat)
3: 10.0.0.42 (apache)
q: 使用本地主机
----------------------------------------------
"'\033[0m'

# 由于暂时没有学习条件判断，所以暂时选择 q
read -p "请输入您要选择的远程主机编号: " host_index
read -p "请输入登录本地主机的用户名: " user

# 远程连接主机
ssh $user@rocky9
```

# 4、表达式

## 4.1运算符

### 4.1.1运算符基础

数据操作

```
关于shell可以实施的数据操作，按照不同的业务场景主要可以分为如下两个方面：
 运算符 - 数据值之间的操作
 赋值运算
 	- 结果值输出
	- 示例： =、*=、/=、%=、+=、-=、<<=、>>=、&=、^=、|=等
 二元运算
 	- 数据值操作
 	- 示例： +、-、*、/、%等
 高阶运算
 	- 更高一级的数学运算
 	- 示例：**、^、++、--、
 其他运算
 	- 其他运算操作
 	- 示例：<<、>>等
注意：
 这些所谓的运算符一般很难单独来使用，都需要结合计算表达式来实现相应的效果
 表达式 - 数据值在特定场景的运算符操作
 计算表达式
 	- 将多个值的运算操作执行起来
 	- 示例：bc、let、expr、$(())等
 测试表达式
 	- 判断结果值是否满足需求
 	- 示例：test、[]等
 逻辑表达式
 	- 多条件的多场景组合
 	- 示例：&&、||、and、or、not、&、|等
 比较表达式
 	- 判断数据之间的适配关系
 	- 示例：-f|d|s、-r|x|w、-e、-n、==、!=、>、<、<=、>=等
 三元表达式
 	- 多逻辑的简单计算表达式
 	- 示例：expr?expr:expr
 集合表达式
 	- 表达式之间的关联关系
 	- 示例：expr1 , expr2、 [[ ]]、[ -a|o ]、[ ! ]等
```

### 4.1.2简单计算

$[]、let、(())、$(())

- $[]

  ```
  格式
  方法1：
  	$[计算表达式]
  方法2：
  	a=$[变量名a+1]
  注意：
  	这里的表达式可以不是一个整体
  ```

  ```
  [root@rocky9 ~]# echo $[100/5]
  20
  [root@rocky9 ~]# echo $[ 2 + 5 ]
  7
  变量参与运算
  [root@rocky9 ~]# a=6
  [root@rocky9 ~]# a=$[a+1]
  [root@rocky9 ~]# echo $a
  7
  运算结果取整
  [root@rocky9 ~]# echo $[100/3]
  33
  ```

- let

  ```
  简介：let是另外一种相对来说比较简单的数学运算符号了
  格式：
  	let 变量名a=变量名a+1
  注意：
   	表达式必须是一个整体，中间不能出现空格等特殊字符
  ```

  ```
  简单运算
  [root@rocky9 ~]# i=1
  [root@rocky9 ~]# let i=i+7
  [root@rocky9 ~]# echo $i
  8
  let表达式必须是一个整体
  [root@rocky9 ~]# let i = i * 2
  bash: let: =: 语法错误: 期待操作数 （错误符号是 "="）
  [root@rocky9 ~]# let i=i * 2
  bash: let: anaconda-ks.cfg: 语法错误: 无效的算术运算符 （错误符号是 ".cfg"）
  [root@rocky9 ~]# let i=i*2
  [root@rocky9 ~]# echo $i
  16
  ```

- (())

  ```
  简介：
  	(())的操作与let基本一致，相当于let替换成了 (())
  格式：
  	((变量计算表达式))
  注意：
  	对于 $(())中间的表达式，可以不是一个整体，不受空格的限制
  ```

  ```
  [root@rocky9 ~]# num1=2
  [root@rocky9 ~]# ((num2=num1+5))
  [root@rocky9 ~]# echo $num2
  7
  ```

- $(())

  ```
  简介：
  	$(())的操作，相当于 (()) + echo $变量名 的组合
  格式
  	echo $((变量计算表达式))
  注意：
   	对于 $(())中间的表达式，可以不是一个整体，不受空格的限制
  ```

  ```
  [root@rocky9 ~]# num1=3
  [root@rocky9 ~]# echo $((num2=num1+4))
  7
  ```

  

### 4.1.3赋值运算进阶

二元运算

简介

```
所谓的二元运算，指的是 多个数字进行+-*/%等运算
```

赋值运算

```
这里的赋值运算，是一种进阶版本的复制操作，常见的样式如下：
	样式1：+=、-=、*=、/=
 		在自身的基础上进行二元运算，结果值还是自己
 	样式2：++、--
 		在自身的基础上进行递增和递减操作，结果值还是自己
```

### 4.1.4expr计算

简介

```
expr即可以做常见的整数运算，还可以做数字比较，字符串计算等操作。
```

格式

```
数字场景：
	expr 运算表达式
字符串场景：
	match：用户获取匹配到字符串的长度
		expr match 字符串 匹配内容
 	substr：截取字符串
 		expr substr 字符串 起始位置 截取长度
 		注意：起始位置值>=1
 	index：查找第一次匹配字符的位置
 		expr index 字符串 字符
 	length：计算字符串的长度
 		expr length 字符串
```

```
数学运算
[root@rocky9 ~]# expr 1 + 2 - 3 \* 4 / 5 + \( 6 - 7 \) \* 8
-7
[root@rocky9 ~]# x=1
[root@rocky9 ~]# expr $x + 4
5
```

### 4.1.5bc计算

简介

```
bc是一种任意精度的计算语言，提供了语法结构，比如条件判断、循环等，功能是很强大的，还能进行进
制转换。
```

```
参数
	-i 强制交互模式；
    -l 使用bc的内置库，bc里有一些数学库，对三角计算等非常实用；
    -q 进入bc交互模式时不再输出版本等多余的信息。
特殊变量
    ibase，obase 用于进制转换，ibase是输入的进制，obase是输出的进制，默认是十进制；
    scale 小数保留位数，默认保留0位。
```

## 4.2表达式

### 4.2.1基础知识

简介

​	所谓的表达式，就是在场景需求的前提下，判断数据和运算符的操作是否满足需求。

格式

```
格式
 	真实值 操作符 真实值 比较运算符 预期值
示例
 	3 + 4 > 6
要点：
 	表达式应该具有判断的功能
```

测试表达式

简介

```
Shell环境根据命令执行后的返回状态值($?)来判断是否执行成功,当返回值为0,表示成功,值为其他
时,表示失败。使用专门的测试工具---test命令，可以对特定条件进行测试，并根据返回值来判断条件是否成立（返回值0为成立）
```

测试表达式

```
样式1: test 条件表达式
样式2: [ 条件表达式 ]
注意：
    以上两种方法的作用完全一样，后者为常用。
    但后者需要注意方括号[、]与条件表达式之间至少有一个空格。
    test跟 [] 的意思一样
        条件成立，状态返回值是0
        条件不成立，状态返回值是1
```

### 4.2.2逻辑表达式

简介

```
逻辑表达式一般用于判断多个条件之间的依赖关系。
常见的逻辑表达式有：&&  和  ||，根据观察的角度不同含义也不同
```

语法解读

```
&&
	示例：命令1  &&  命令2
 		如果命令1执行成功，那么我才执行命令2 	-- 夫唱妇随
 		如果命令1执行失败，那么命令2也不执行
```

```
||
	示例：命令1 || 命令2
 		如果命令1执行成功，那么命令2不执行 		-- 对着干
 		如果命令1执行失败，那么命令2执行
```

```
!
	示例：! 命令
 		如果命令执行成功，则整体取反状态
```

组合使用

```
使用样式：
 	命令1 && 命令2 || 命令3
   		方便理解的样式  ( 命令1 && 命令2 ) || 命令3
功能解读：
 	命令1执行成功的情况下，执行命令2
 	命令2执行失败的情况下，执行命令3
注意：
 	&& 必须放到前面，|| 放到后面
```

```
root@bogon:~ $ [ 1 = 2 ] && echo "条件成立" || echo "条件不成立"
条件不成立
root@bogon:~ $ [ 1 = 1 ] && echo "条件成立" || echo "条件不成立"
条件成立
```

### 4.2.3字符串表达

简介：所谓的字符串表达式，主要是判断 比较运算符 两侧的值的内容是否一致，由于bash属于弱类型语言，所以，默认情况下，无论数字和字符，都会可以被当成字符串进行判断。

符号解读

```
内容比较判断
    str1 == str2 		str1和str2字符串内容一致
    str1 != str2 		str1和str2字符串内容不一致，!表示相反的意思
内容空值判断
    -z str 			空值判断，获取字符串长度，长度为0，返回True
    -n  "str" 		非空值判断，获取字符串长度，长度不为0，返回True
   					注意：str外侧必须携带"",否则无法判断
```

### 4.2.4文件表达式

简介：所谓的文件表达式，主要是判断文件相关的权限和属性信息的。

表达式解读

```
文件属性判断
	-d  检查文件是否存在且为目录文件
    -f  检查文件是否存在且为普通文件
    -S 检查文件是否存在且为socket文件
    -L 检查文件是否存在且为链接文件
    -O  检查文件是否存在并且被当前用户拥有
    -G  检查文件是否存在并且默认组为当前用户组
    
文件权限判断
	-r  检查文件是否存在且可读
    -w  检查文件是否存在且可写
    -x  检查文件是否存在且可执行
    
文件存在判断
	-e  检查文件是否存在
    -s  检查文件是否存在且不为空
    
文件新旧判断
    file1 -nt file2  检查file1是否比file2新
    file1 -ot file2  检查file1是否比file2旧
    file1 -ef file2  检查file1是否与file2是同一个文件，判定依据的是i节点
```

### 4.2.5数字表达式

简介：主要根据给定的两个值，判断第一个与第二个数的关系，如是否大于、小于、等于第二个数。

```
n1 -eq n2   相等  n1 = n2
n1 -ne n2   不等于  n1 != n2
n1 -ge n2   大于等于 n1 >= n2
n1 -gt n2   大于  n1 > n2
n1 -lt n2   小于  n1 < n2
n1 -le n2   小于等于 n1 <= n2
```

```
需求：
    如果文件没有权限，就赋权
    如果文件有执行权限，就执行
    [ -x /path/to/scripts ] && /path/to/scripts || chmod +x /path/to/scripts
```



## 4.3 表达式进阶

简介：

​		我们之前学习过 test 和 [ ] 测试表达式，这些简单的测试表达式，仅仅支持单条件的测试。如果需要针对多条件测试场景的话，我们就需要学习[[  ]] 测试表达式了。

​		我们可以将 [[  ]] 理解为增强版的 [ ]，它不仅仅支持多表达式，还支持扩展正则表达式和通配符。

```
基本格式：
 [[ 源内容 操作符 匹配内容 ]]
 
操作符解析：
 == 左侧源内容可以被右侧表达式精确匹配
 =~ 左侧源内容可以被右侧表达式模糊匹配
```

表现样式

| A条件 | B条件 | 非A（！A） | A或B[A\|B] | A与B[A&B] |
| :---: | :---: | :--------: | :--------: | :-------: |
|  真   |  真   |     假     |     真     |    真     |
|  真   |  假   |     假     |     真     |    假     |
|  假   |  假   |     真     |     真     |    假     |
|  假   |  假   |     真     |     假     |    假     |

表现样式

```
两个条件
 1 - 真 				0 - 假
三种情况：
 与 - & 		或 - | 		非 - !
 
注意：
 这里的 0 和 1 ，千万不要与条件表达式的状态值混淆
```

```
与关系
	0 与 0 = 0 		0 & 0 = 0
 	0 与 1 = 0 		0 & 1 = 0
 	1 与 0 = 0 		1 & 0 = 0
 	1 与 1 = 1 		1 & 1 = 1
```

```
或关系
	0 或 0 = 0 		0 | 0 = 0
    0 或 1 = 1 		0 | 1 = 1
    1 或 0 = 1 		1 | 0 = 1
    1 或 1 = 1 		1 | 1 = 1
```

```
非关系
	非 1 = 0   		! true = false
    非 0 = 1 		! false = true
```

**逻辑组合**

简介：所谓的条件组合，指的是在同一个场景下的多个条件的综合判断效果。

```
方法1：
 [ 条件1 -a 条件2 ] - 两个条件都为真，整体为真，否则为假
 [ 条件1 -o 条件2 ] - 两个条件都为假，整体为假，否则为真
方法2：
 [[ 条件1 && 条件2 ]] - 两个条件都为真，整体为真，否则为假
 [[ 条件1 || 条件2 ]] - 两个条件都为假，整体为假，否则为真
```









20250316
