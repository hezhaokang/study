# 12 进程-系统性能和计划任务

## 1 进程管理

### 1.1概述

内核是操作系统最基本的部分，它的功能非常强大且多样

```
系统调用接口：
 	这是内核与应用软件之间的桥梁，它允许应用软件通过系统调用来请求内核提供的服务，如文件操作、进程控制等。

进程管理：
 	内核负责创建、销毁、调度和同步进程。它确保每个进程都能公平地获得CPU资源，同时防止进程间的非法访问和干扰。

内存管理：
 	内核管理计算机的内存资源，包括物理内存和虚拟内存的分配、回收和保护。它确保每个进程都有足够的内存来执行其任务，同时防止内存泄漏和非法访问。

文件系统管理：
 	内核提供对文件和文件夹的管理和访问功能，包括文件的创建、读取、写入、删除和重命名等。它确保文件系统的完整性和安全性，同时提供方便的文件访问接口。

设备驱动：
 	内核提供对硬件设备的访问接口，包括输入输出设备、存储设备和网络设备等。它通过与硬件设备的驱动程序交互，实现设备的初始化、配置和控制等功能。

硬件抽象：
 	内核提供硬件抽象层，隐藏了硬件的复杂性和差异性，为应用软件提供了一套简洁、统一的接口。这使得
应用软件可以无需关心底层硬件的具体实现，从而专注于实现其业务逻辑
```

#### CPU分片机制

![image-20241119090736725](5day-png\12概述分片机制.png)

```
	CPU分片机制，也称为时间分片或轮转调度，是操作系统用来管理和分配CPU时间的策略。在这种机制下，操作系统将CPU的执行时间分割成固定或可变长度的时间片，每个进程或线程获得一个时间片来执行其任务。这种机制确保了每个进程或线程都能获得一定的CPU时间，从而实现了并发执行
	
注意：cpu 没有空闲的概念，只有空转
```

#### 进程管理概念

```
	进程管理是指操作系统对系统中所有进程进行有效的监控、调度和控制的过程。进程是操作系统进行资源分配和调度的基本单位，它代表了程序的执行实例。
 	进程是程序的一次执行过程，它包含了程序的代码、数据和运行状态等信息。每个进程都有一个唯一的标识符（PID），用于区分不同的进程。
```

#### 进程的状态

```
进程的状态包括就绪态、运行态、阻塞态和终止态等，这些状态的转换与CPU分片机制密切相关。
	就绪态表示进程已经准备好执行，但尚未被分配CPU资源；
	运行态表示进程正在占用CPU资源执行；
	阻塞态表示进程因为等待某个事件（如I/O操作）而无法继续执行；
	终止态表示进程已经执行完毕或被操作系统强制终止。
        
CPU分片机制使得进程的状态转换更加频繁和高效，从而提高了系统的响应速度和吞吐量。
```

#### 进程调度

```
	进程调度是操作系统根据一定的策略，也是进程调度的核心部分，它决定了哪个就绪进程或线程将在何时获得CPU资源。CPU分片机制为进程调度提供了基础。通过时间分片，操作系统可以确保每个进程或线程都能获得公平的CPU时间，从而实现高效的并发执行。
 	常见的进程调度策略包括：
 		先来先服务（FCFS）、短作业优先（SJF）、优先级调度和时间片轮转（Round Robin）等。
```

#### 进程通信

```
	进程同步是指多个进程在执行过程中需要按照某种顺序来协调它们的执行。常见的进程同步机制包括信号量、互斥锁、条件变量和读写锁等。
 	进程通信是指多个进程之间需要进行数据交换和信息传递的过程。常见的进程通信方式包括管道、消息队列、共享内存和套接字等。 
```

#### 进程控制

```
	进程控制是指操作系统对进程进行创建、撤销、挂起和恢复等操作的过程。创建进程通常是通过系统调用或命令来实现的，撤销进程则可以通过正常结束或异常终止来完成。挂起进程是指将进程暂时从内存中移除并保存到磁盘上，以便在需要时再重新加载到内存中执行。恢复进程则是指将挂起的进程重新加载到内存中并继续执行。
 
 	CPU分片机制使得操作系统能够更灵活地分配CPU资源，也是实现进程并发执行的基础。通过调整时间片的大小和数量，操作系统可以根据系统的负载和性能需求来优化CPU的利用率。在单核处理器上，通过时间分片可以模拟出并发的效果。而在多核处理器上，CPU分片机制则可以更好地支持并行执行。
```

#### 总之

```
	进程管理是操作系统中的一个重要功能，它负责监控、调度和控制计算机系统中所有进程的执行。通过有效的进程管理，可以提高系统的资源利用率和吞吐量，同时保证系统的稳定性和可靠性。
```

![image-20241119141554406](5day-png\12概述进程管理.png)

### 1.2进程基础

#### **什么是进程**

```
	进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，也是操作系统结构的基础。它既是程序的执行实例，也是程序在操作系统中的动态表现。
	简单来说，进程是运行中的程序。
```

#### 进程特点

```
	动态性：进程是动态产生的，随着程序的执行而不断变化，并在执行完毕后动态消亡。
	独立性：进程是一个独立的运行实体，拥有自己独立的地址空间和系统资源，如处理器、存储器、I/O设备等。
	异步性：由于进程间的相互制约和资源共享，使得进程的执行具有间断性，即进程按各自独立的、不可预知的速度向前推进。
	并发性：多个进程可以在同一时间段内并发执行，共享系统资源。
```

#### 表现样式

```
Process: 运行中的程序的一个副本，是被载入内存的一个指令集合，是资源分配的单位
    - 进程ID（Process ID，PID）号码被用来标记各个进程
    - UID、GID、和SELinux语境决定对文件系统的存取和访问权限
    - 通常从执行进程的用户来继承
    - 存在生命周期
```

#### 进程分类

```
按操作系统分类：
- 协作式多任务：
 	早期 windows 系统使用，即一个任务得到了 CPU 时间，除非它自己放弃使用CPU ，否则将完全霸占CPU ，所以任务之间需要协作——使用一段时间的 CPU ，主动放弃使用。

- 抢占式多任务：
 	Linux内核，CPU的总控制权在操作系统手中，操作系统会轮流询问每一个任务是否需要使用 CPU ，需要使用的话就让它用，不过在一定时间后，操作系统会剥夺当前任务的 CPU 使用权，把它排在询问队列的最后，再去询问下一个任务。
```

```
按进程运行方式分类：
	- 守护进程: daemon，在系统引导过程中启动的进程，和终端无关进程
	- 前台进程：跟终端相关，通过终端启动的进程
	注意：两者可相互转化
```

```
按进程资源使用的分类：
    - CPU-Bound：CPU 密集型，非交互
    - IO-Bound：IO 密集型，交互
```

#### 系统进程

```
- init：第一个进程，从 CentOS7 以后为 systemd 
- 进程：都由其父进程创建，fork()，父子关系，CoW：Copy On Write (读时共享，写时复制)

进程之间有父进程和子进程的关系，所有的应用程序的父进程都是 系统systemd进程的子进程。
```

#### 进程结构

```
每个进程都有自己的资源，由操作系统分配，内存，栈，文件描述符等信息。
进程由程序、数据和进程控制块（Program Control Block，PCB）三部分组成。
 	程序是进程要执行的指令集合，
 	数据是进程在执行过程中需要处理的信息，
 	进程控制块则包含了进程的各种信息和控制信息，
 		如进程标识符（PID）、状态、优先级、程序计数器、寄存器集合等。
```

![image-20241119143253917](5day-png\12进程管理进程基础.png)

#### 线程

```
	线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。
 	一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。
```

| 属性 | 进程                                                         | 线程                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义 | 进程是操作系统资源分配的基本单位，它表示一个正在执行的程序实例。每个进程都有自己独立的代码和数据空间（程序上下文），以及系统分配的资源，如内存、文件句柄等。 | 线程是任务调度和执行的基本单位，它是进程中的一个执行实体。线程共享进程的资源，但每个线程都有自己独立的运行栈和程序计数器（PC）。线程使得程序能够并发执行多个任务。 |
| 开销 | 由于进程拥有独立的代码和数据空间，以及系统资源，因此在进程间切换时需要较大的开销，包括保存和恢复上下文、切换内存空间等。 | 线程切换时开销较小，因为线程共享进程的内存和资源，只需要切换线程的上下文即可。这使得多线程程序能够更高效地利用系统资源。 |
| 通信 | 进程是一个独立的运行实体，它可以独立地分配资源和调度。进程间的通信需要通过进程间通信（IPC）机制来实现。 | 线程共享进程的内存和资源，这使得线程间的通信更加高效。线程间的通信通常通过共享内存或消息传递来实现。 |
| 场景 | 适用于需要独立运行、资源隔离和较高安全性的场景，如操作系统中的服务进程、网络服务器等。 | 适用于需要高效并发执行、共享资源和较低开销的场景，如GUI应用程序中的事件处理线程、多线程服务器等。 |

#### 其他区别

```
包含关系：
 一个进程可以拥有多个线程，但一个线程只能属于一个进程。线程是进程的一部分，也被称为轻量级进程。

资源分配：
 进程拥有独立的内存单元和资源，而线程则共享进程的资源。这使得线程在切换时开销较小，因为不需要切换整个进程的上下文。
```

```
并发：
 	进程和线程都可以实现并发执行。并发是指多个任务在同一时间段内交替执行，而不是同时执行。进程并发通常通过时间片轮转等调度算法来实现。

并行：
 	线程更易于实现并行执行，因为线程间的切换开销较小。并行是指多个任务在同一时间段内同时执行，这通常需要多核处理器或超线程技术的支持。
```

#### 关联关系

```
查看进程的相关信息
 	ls /proc/PID
查看进程中的线程 - 包括进程本身
 	grep -i threads /proc/PID/status
查看进程的二进制文件
 	ll /proc/PID/exe
查看进程打开的文件
 	/proc/PID/fd/
```

```
查看系统进程
root@openEuler:~ # pstree -p | head -4
systemd(1)-+-NetworkManager(1058)-+-teamd(1119)
           |                      |-{NetworkManager}(1072)
           |                      |-{NetworkManager}(1073)
           |                      `-{NetworkManager}(1074)
           
注意：
 {} 是线程的标识， () 是进程的标识
```

```
查看进程中的线程
root@openEuler:~ # grep -i threads /proc/1058/status
Threads:        4
					# 包含进程自身，一共4个
```

```
查看进程的二进制文件
root@openEuler:~ # ls /proc/1058/exe
/proc/1058/exe
root@openEuler:~ # ls /proc/1058/exe -l
lrwxrwxrwx. 1 root root 0 11月15日 19:57 /proc/1058/exe -> /usr/sbin/NetworkManager

查看进程打开的文件
root@openEuler:~ # ls /proc/1058/fd
0  1  10  11  12  13  14  15  16  17  18  19  2  20  21  22  23  24  25  26  27  28  29  3  30  31  4  5  6  7  8  9
root@openEuler:~ # ls /proc/1058/fd -l
总计 0
lr-x------. 1 root root 64 11月15日 19:57 0 -> /dev/null
lrwx------. 1 root root 64 11月15日 19:57 1 -> 'socket:[10358]'
lrwx------. 1 root root 64 11月17日 09:58 10 -> 'socket:[10403]'
lrwx------. 1 root root 64 11月17日 09:58 11 -> 'socket:[10404]'
```

#### 多进程查看

```
root@openEuler:~ # pstree -p | grep nginx
           |-nginx(27221)-+-nginx(27222)
           |              `-nginx(27223)
```

#### 多线程查看

```
root@ubuntu:~ # pstree -p | grep redis
           |-redis-server(1223)-+-{redis-server}(1238)
           |                    |-{redis-server}(1239)
           |                    |-{redis-server}(1240)
           |                    `-{redis-server}(1241)
```

### 1.3 进程结构

进程的结构可以简要描述为以下几个核心部分

```
程序代码：
    表示进程正在执行的程序代码，它通常存储在内存中的代码段中。
    程序代码是进程执行的基础，由CPU读取指令并执行。
```

```
数据：
    表示进程正在使用的数据，包括全局变量、局部变量、常量等。
    数据通常存储在内存中的数据段中，供程序代码在运行时读取和修改。
```

```
进程控制块（PCB）：
    是进程存在的唯一标志，用于记录进程的状态和相关信息。
    PCB中包含了进程的ID、优先级、状态（如就绪、运行、阻塞等）、输入输出信息等。
    PCB通常会存储在操作系统内核中，以便操作系统对进程进行管理和调度。
```

#### 任务列队 

```
内核把进程存放在叫做任务队列（task list)的双向循环链表中
 	链表中的每一项都是类型为task_struct，称为进程控制块（Processing Control Block），PCB中包含一个具体进程的所有信息
```

![image-20241119145926954](5day-png\12进程管理进程结构任务列队.png)

```
proc_list.sh
```

### 1.4进程相关概念

#### 基本概念

```
CPU：
 	中央处理器，是计算机的核心部件，负责执行程序中的指令，处理数据。
页表：
 	Page Frame，即页框，是指物理内存中被划分为固定大小的内存访问单位。这些固定大小的块通常用于存储虚拟内存中的页面，以实现虚拟内存与物理内存之间的映射和转换。
```

```
MMU：Memory Management Unit
 	内存管理单元，是CPU中用于管理虚拟存储器和物理存储器的控制线路。它负责将虚拟地址映射为物理地址，并提供硬件机制的内存访问授权。
TLB：Translation Lookaside Buffer
 	传输后备缓冲器，是MMU中用于改进虚拟地址到物理地址转换速度的缓存。它存储了虚拟地址与物理地址之间的映射关系，以加速地址转换过程。
```

```
虚拟地址：
 	用户编程时使用的地址，由段选择符和段内偏移地址组成。它不是物理内存中的实际地址，而是由操作系统和MMU共同管理的一个地址空间。
物理地址：
	物理内存中的实际地址，用于唯一标识内存中的每个存储单元。CPU通过物理地址来访问内存中的数据。
```

#### 关联关系

```
前提：
 	虚拟地址是用户编程时使用的地址，不是物理内存中的实际地址。
程序执行的时候：
    CPU发出内存访问请求时，使用的是虚拟地址。
    MMU截获这些虚拟地址，并将其转换为物理地址。
    MMU还负责提供硬件机制的内存访问授权，确保CPU只能访问被授权的内存区域。
    
真实数据的对应关系
 	TLB中存储了虚拟地址与物理地址之间的映射关系。
 	MMU利用TLB来加速虚拟地址到物理地址的转换过程。
 	当CPU访问内存时，MMU首先会在TLB中查找对应的映射关系。如果找到，则直接使用该映射关系进行地址转换；如果未找到，则需要在页表中查找。
```

```
完整逻辑
    当CPU需要访问内存时，它首先发出一个虚拟地址。
    MMU截获这个虚拟地址，并在TLB中查找对应的物理地址。
    如果TLB中找到了对应的映射关系，则直接使用该物理地址访问内存。
    如果TLB中未找到对应的映射关系，则MMU需要在页表中查找。
    MMU根据页表找到对应的物理地址后，将其发送给CPU，CPU再根据该物理地址访问内存。
```

#### 页表

```
Page Frame，即页框，是指物理内存中被划分为固定大小的内存访问单位。这些固定大小的块通常用于存储虚拟内存中的页面，以实现虚拟内存与物理内存之间的映射和转换。
```

```
Page Frame: 页框，用存储页面数据，存储 Page 4k
root@openEuler:~ # getconf -a | grep -i size
PAGESIZE                           4096
PAGE_SIZE                          4096
```

#### 物理地址空间和虚拟地址空间

```
MMU：Memory Management Unit 负责虚拟地址转换为物理地址
 	程序在访问一个内存地址指向的内存时，CPU不是直接把这个地址送到内存总线上，而是被送到MMU（Memory Management Unit)，然后把这个内存地址映射到实际的物理内存地址上，然后通过总线再去访问内存，程序操作的地址称为虚拟内存地址
 
TLB：Translation Lookaside Buffer 翻译后备缓冲区，用于保存虚拟地址和物理地址映射关系的缓存
```

![image-20241119154452730](5day-png\12进程管理进程相关概念MMN.png)

#### 用户和内核空间

![image-20241119155041097](5day-png\12进程管理内核2.png)

```
用户空间（User Space）
 	用户空间是操作系统中运行用户应用程序的内存区域。它通常位于较低的地址范围。用户进程在用户空间中运行，拥有受限的权限。它们不能直接访问硬件资源或执行某些特权操作，例如修改内存映射、访问其他进程的内存等。
 
 	用户空间主要负责执行应用程序逻辑，如数据处理、文件操作、网络通信等。这些操作通过调用系统提供的API（应用程序接口）来实现。由于用户进程拥有受限的权限，它们对系统的影响相对较小。即使一个用户进程崩溃，也不会直接影响内核或其他用户进程。
```

```
内核空间（Kernel Space）
 	内核空间是操作系统内核运行的内存区域。它通常位于较高的地址范围。内核拥有最高的权限，可以执行任何操作，包括访问硬件、管理内存、调度进程、处理中断等。
 	内核空间负责提供系统调用接口（System Call Interface），允许用户进程请求内核服务。内核还负责管理硬件资源、文件系统、进程调度、内存管理等底层操作。内核崩溃或错误可能会导致整个系统崩溃，因为内核拥有控制整个系统的权限。因此，内核的设计和实现需要非常谨慎，以确保其稳定性和安全性。
```

#### 用户空间和内核空间的交互

```
系统调用：
 	当用户进程需要执行特权操作时，它会通过系统调用接口请求内核服务。系统调用是用户空间与内核空间之间通信的主要方式。
 
中断和异常：
 	硬件中断和异常处理也会触发从用户空间到内核空间的转换。例如，当用户态程序执行系统调用过程中，因为牵扯到特权指令，导致用户态程序无法执行，只能触发中断，然后交由内核空间的程序处理，内核会处理完成后，再次触发中断，切回用户态工作，并可能更新用户进程的状态。
 
上下文切换：
 	在进程调度过程中，当CPU从一个用户进程切换到另一个用户进程或切换到内核线程时，也会发生用户空间与内核空间之间的转换。
```

![image-20241119160645890](5day-png\12内核3.png)

```
每个进程都包括5种不同的数据段
- 代码段：
 	用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
- 数据段：
 	用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。
- BSS段：
 	Block Started by Symbol”的缩写,意为“以符号开始的块，BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。
- 堆（heap）：
 	存放数组和对象，堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。
- 栈（stack）：
 	栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。可以把堆栈看成一个寄存、交换临时数据的内存区。
```

![image-20241119160826164](5day-png\12内核队列.png)

#### 操作系统层结构

![](5day-png\12进程管理内核.png)

```
第二层
	时钟管理：
		应用场景：CPU时间分片
	中断处理
		应用场景：时钟中断，操作系统状态切换，
	原语：原子的原，表示一种执行起来，不可中断的程序，它会一口气执行到结束
		设备驱动
		CPU切换

第三层
	这里设计到操作系统的一些功能：进程管理，存储（内存）管理，设备管理，文件系统等在裸机之上，有两层是操作系统内核的功能
	
第四层: 非内核功能
	非内核功能：比如Linux操作系统，它是一个什么样的操作系统呢，它其实就是以linux为内核的一系列操作系统，我们把它们统称为Linux操作系统，那么对于这些操作系统，它们相同的都是使用的是LInux内核，而不同的是非内核功能，也就是操作系统里面个性化定制的一些应用程序，所有以Linux为内核开发的操作系统，统称Linux操作系统
	
第五层：应用程序
	通常是用户使用安装的应用程序
```

#### **内核**

内核是操作系统最基本，最核心的部分 实现操作系统内核功能的那些程序就是 **内核程序**

##### 宏内核和微内核

```
宏内核(大内核)
	在我们通用的操作系统中，大多数操作系统都是大内核的
	就是把第二、三层作为内核功能
微内核(小内核) 
	该体系认为内核功能没有必要做的特别复杂，我们把内核功能就做核心的三个：时钟管理，中断处理，原语
	把三层以上包括三层，都变成非内核功能
	微内核仅包含时钟，中断，原语三部分功能，而进程管理，内存管理，设备管理等交给非内核功能去实现
```

##### **比较宏内核和微内核的两种机制：**

宏内核

![image-20241119161813719](5day-png\12内核宏内核.png)

微内核

![image-20241119161910662](5day-png\内核微内核.png)

```
宏内核和微内核的对比
宏内核：
	优点：
		资源利用率更高，高性能 
	缺点：
		当前linux内核代码已经超3000万行，如此庞大的代码量，无论是维护还是升级更新都很麻烦

微内核
	优点：
		内核功能少，结构清晰，因为第三层设备管理，内存管理，进程管理等功能作为用户空间的的程序，这就意味着，普通开发者也可以去开发和优化，只有核心功能是由操作系统内核提供的，上层的进程，内存，设备管理都变成了应用层软件，都是用户软件，因此：开发成本降低，升级更新，维护成本也会变低
	缺点：
		需要频繁的在内核和用户态之间切换，性能差

典型的大内核/宏内核操作系统：Linux、Unix
典型的微内核操作系统：Windows NT
```

#### **操作系统运行机制**

```
应用程序和内核程序
普通程序的执行过程：
高级语言代码 ------- 通过编译 ----> 机器指令 ------> CPU处理
int x = 1; x++; ------> 0110101010101 --------> CPU处理
普通程序员写的程序大多是“应用程序”
微软、苹果等负责开发实现操作系统的人，他们写的是“内核程序”，有很多内核程序组成的就是操作系统内核，内核是操作系统最核心的部分，也是最接近硬件的部分
甚至可以说，一个操作系统只要有内核就够了（比如：Docker ---> 仅需Liux内核，因此容器化技术比虚拟化技术能强悍一些，它需要的资源更少，运行成本更低）
```

##### **特权指令和非特权指令** 

```
非特权指令
	应用程序只能使用“非特权指令”，如加法指令，减法指令，这种数学操作，不需要操作系统的额外硬件就可以执行的指令，仅需要CPU就可以处理，我们不需要访问磁盘，不需要访问外设就可以做的事情，就是非特权指令
```

```
特权指令
	内核程序中，操作系统作为管理者，用来操作计算机资源的指令称为特权指令，比如：C语言中的memset()将一段内存清0，又或者打开文件，打开设备，这些都是特权指令
```

```
在CPU设计和生产的时候，就划分了特权指令和非特权指令，这里其实有是CPU指令集中就已经区分好的，因此CPU执行指令前，一定就能够判断这条指令它到底是什么类型，是特权指令还是非特权指令，所谓特权指令就是操作系统作为管理者，它来管理计算机资源用到的指令，而非特权指令时应用程序可以直接做的，常见的就是数学计算。
```

##### **内核态和用户态**

```
CPU有两种状态，“内核态”和“用户态”（重要）
	用于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令（当然也可以执行非特权指令）
	用于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令
		(如果当前处于用户态，你却非要调用特权指令，CPU就会报错)
	拓展：CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示内核态，0表示用户态，所以CPU在每个时刻可以去看自己的寄存器，里面的值是多少，进而判断当前状态
	
	别名：内核态=核心态=管态； 用户态=目态
```

**理解内核态和用户态的意义**

```
当我们进行程序设计或者管理维护的时候，特别是大型软件设计与优化，我们会考虑我们的应用程序它的性能，常见的会影响程序性能的其中一个问题就是：由程序引起的用户态到内核态的一个频繁切换，如果过于频繁切换，就会导致程序效率底下，这也是了解内核态和用户态的意义之一
```

**内核态和用户态的切换**

```
内核态和用户态的切换
内核态 -> 用户态：
	执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权，此时CPU的使用权归用户态，内核态到用户态是由操作系统主动让出的，它让出的过程就是使用一个特权指令，修改PSW寄存器上的值

用户态 -> 内核态：
	由“中断”引发，硬件自动完成变态过程(除了非法使用特权指令外，还有很多事情会触发中断信号。一个共性是，但凡需要操作系统介入的地方，都会触发中断信号)，触发中断信号意味着操作系统将强行夺回CPU的使用权每个进程都是自私的，都希望拥有更多的CPU时间，所以用户态不可能主动让出CPU，所以从用户态到内核态通常需要由中断引起，这个中断通常是硬件自动完成的
```

**触发中断的几种常见情况（共性：凡是需要操作系统介入的地方）**

```
	用户态应用程序非法使用特权指令，会被操作系统中断，并夺回CPU控制权
	程序执行过程中，被分配的CPU时间片的时间到了，也触发中断，然后被夺回CPU控制权
	除0，非法操作
	应用程序操作鼠标键盘，这个操作鼠标硬盘，这种IO操作，必须交给操作系统内核去做 ，这个也会产生中断，这个通常是通过系统调用实现的，这里有个概念："陷入"（从用户态陷入内核态）
```

#### 中断(Interrupts)和异常

**异常（内中断）** 

```
CPU内部产生的错误
	除0
	内存越界产生的段错误等
	陷入指令
	故障：访问内存，但所需数据并不在访问的内存中，就会引发故障，故障就是我出错了，但是没关系，下次重新做，可以由操作系统修改的
	终止（除零，段错误），只能杀死进程
```

**中断（外中断）**

```
外部信号导致CPU中断，就是中断
“中断”是让操作系统内核夺回CPU使用权的唯一途径
如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个程序，直到程序执行结束，或者程序主动让出CPU的使用权，而这种程序主动让出使用权的方式，风险很大。因此需要一种机制让应用程序让出CPU，这种就是中断
```

**内中断**

```
与当前执行的指令有关（比如CPU在执行指令的时候发现了问题），中断信号来源于CPU内部
```

**外中断**

```
与当前执行的指令无关，中断信号来源于CPU外部
	时钟信号
	进行写操作，但是写入的磁盘地址错误发生中断，这种中断是在CPU外部产生的，因此是外中断
	时钟中断
	IO中断，由输入输出设备发出的中断信号
```

**陷入**

```
trap指令（陷入指令）：由用户态进入内核态的过程，也就是CPU的使用权由用户态转交给内核态的过程
```

**中断的基本原理**

```
不同的中断信号，需要用不同的中断处理程序来处理，当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中存放的位置
	中断向量表：本质是一个数组，里面存放着一个个中断处理程序的指针，下标表示一个个中断信号类型显然，中断处理程序一定是内核程序，需要运行在内核态
```

#### **系统调用**(system call)

​	**接口**

```
操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组 系统调用 组成
	用户与计算机系统之间的接口
		给用户使用的
			CUI
			命令接口
				联机命令接口
				脱机命令接口
		给应用程序使用的
			程序接口（系统调用）
```

**系统调用和库函数的区别**

```
有些库函数包含系统调用，有些不包含，取决于是否需要调用内核资源
	普通应用程序
		可直接进行系统调用，也可使用库函数，有的库函数涉及系统调用，有的不涉及
	编程语言
		向上提供库函数。有时会将系统调用封装成库函数，以及隐藏系统调用的一些细节，使程序员编程更方便
	操作系统
		向上提供系统调用，使得上层程序能请求内核服务
```

**什么功能要系统调用实现**

```
应用程序通过 系统调用 请求操作系统的服务，而系统中的各种共享资源都是由操作系统内核同一掌管，因此凡是与共享资源相关的操作(如存储分片，IO操作，文件管理等)，都必须通过系统调用的方式（方向性）向操作系统内核提出服务请求，有操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。
```

**应用程序使用系统调用的过程**

```
传递系统调用参数 -> 执行陷入指令（用户态）-> 执行相应的内核程序处理系统调用 -> 返回发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行
```

### 1.5内存问题

#### 内存泄露Memory Leak

```
	内存泄露是指程序在动态分配内存后，未能正确释放这些内存空间，导致系统无法回收这部分内存空间。内存泄露通常表现为程序运行过程中占用的内存空间不断增大，直至耗尽系统资源，导致程序崩溃或异常。比如：指程序中用malloc或new申请了一块内存，但是没有用free或delete将内存释放，导致这块内存一直处于占用状态。

示例：
 	每次去图书馆借书，但是就是不还，终有一天图书馆没书了。
```

#### 内存溢出：Memory Overflow

```
溢出是指数据超出了其存储空间的范围，导致数据损坏或程序崩溃。常见的溢出类型包括整数溢出和缓冲区溢出。简单来说就是：指程序申请了20M的空间，但是在这个空间写入20M以上字节的数据，就是溢出。
```

#### 内存不足：OOM

```shell
OOM即 Out Of Memory 内存用完了，是指系统或应用程序在运行时因内存不足而无法继续执行的情况。这通常会导致应用程序崩溃或系统变得不稳定。这种情况在java程序中比较常见。系统会选一个进程将之杀死，在日志messages中看到类似下面的提示
	Jul 10 10:20:30 kernel: Out of memory: Kill process 9527 (java) score 88 or sacrifice child
```

```
常见原因：
    1 内存泄漏：长时间运行的应用程序可能会因为内存泄漏而逐渐耗尽内存。内存泄漏是指程序在动态分配内存后，未能正确释放这些内存空间，导致系统无法回收这部分内存空间。
    2 大型对象或数组：应用程序请求创建的对象或数组过大，超过了系统或JVM堆内存的限制。
    3 系统资源紧张：系统同时运行多个大型程序或进程，导致内存资源紧张。
    4 JVM堆内存设置过小：JVM堆内存设置过小，无法满足应用程序的需求。
```

```
内存超配
 Linux默认是允许memory overcommit的，只要你来申请内存我就给你，寄希望于进程实际上用不到那
么多内存，但万一用到那么多了呢？Linux设计了一个OOM killer机制挑选一个进程出来杀死，以腾出部分
内存，如果还不够就继续。也可通过设置内核参数 vm.panic_on_oom 使得发生OOM时自动重启系统。这都
是有风险的机制，重启有可能造成业务中断，杀死进程也有可能导致业务中断。所以Linux 2.6之后允许通过
内核参数 vm.overcommit_memory 禁止memory overcommit。
```

```
vm.overcommit_memory 接受三种取值:
 	0： Heuristic overcommit handling. 这是缺省值，它允许overcommit，但过于明目张胆的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。Heuristic的意思是“试探式的”，内核利用某种算法猜测你的内存申请是否合理，它认为不合理就会拒绝overcommit。
 
 	1：Always overcommit，允许overcommit，对内存申请来者不拒。内核执行无内存过量使用处理。使用这个设置会增大内存超载的可能性，但也可以增强大量使用内存任务的性能。
 
     2：Don’t overcommit. 禁止overcommit。 内存拒绝等于或者大于总可用 swap 大小以及overcommit_ratio 指定的物理 RAM 比例的内存请求。如果希望减小内存过度使用的风险，这个设置就是
最好的。
```

### 1.6进程状态

```
创建状态：
 	进程在创建时需要申请一个空白PCB(process control block进程控制块)，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态；

就绪状态：
 	进程已准备好，已分配到所需资源，只要分配到CPU就能够立即运行；

执行状态：
 	进程处于就绪状态被调度后，进程进入执行状态；

阻塞状态：
 	正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用；

终止状态：
 	进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行；
```

```
STAT字段解析
    D：不可中断的睡眠状态。
    R：运行或可运行状态。
    S：可中断的睡眠状态。
    T：停止或被跟踪状态。
    Z：僵尸状态（已经终止，但父进程尚未读取其退出状态）。
    I：空闲（Idle）或可中断的睡眠状态（Interruptible Sleep）的变种。 
   	I 后跟 < 或 > 可能表示特定的内核线程状态，不是严格意义上的“睡眠”状态。
 		I<：表示一个低优先级的内核线程，它正在等待某个事件，但可以被信号中断。
 		I>：这个组合不太常见，理论上可能表示一个高优先级的内核线程。
```

进程更多的状态

```
- 运行态：running
- 就绪态：ready
- 睡眠态：分为两种，可中断：interruptable，不可中断：uninterruptable
- 停止态：stopped，暂停于内存，但不会被调度，除非手动启动
- 僵死态：zombie，僵尸态，结束进程，父进程结束前，子进程不关闭，杀死父进程可以关闭僵死态的子进程
```

状态之间转换六种情况

![image-20241119164940435](5day-png\进程状态.png)

```
运行——>就绪：
 	1：主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；
 	2：在采用抢先式优先级调度算法的系统中，当有更高优先级的进程要运行时，该进程就被迫让出CPU，
该进程便由执行状态转变为就绪状态；

就绪——>运行：
 	运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU；

运行——>阻塞：
 	正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求；

阻塞——>就绪：
 	进程所等待的事件已经发生，就进入就绪队列；
```

僵尸进程

```
	进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸(zombie)进程。
 	这样就会导致 如果进程不调用wait()或waitpid()的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但系统所能使用的进程号是有限的，如果大量产生僵尸进程，将因为没有可用进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。
```

孤儿进程

```
	如果在子进程在退出前，父进程先退出，这时子进程将成为孤儿进程，因为它的父进程已经死了。孤儿进程会被PID=1的systemd进程收养，成为systemd的子进程。
 	注意，孤儿进程还会继续运行，而不会随父进程退出而终止，只不过其父进程发生了改变。
```

### 1.7清理策略

#### 内存淘汰策略

```
内存淘汰策略，让进程自己能依据某种规则来管理内存空间，保证程序不会因为内存耗尽而无法工作。
```

```
先进先出（FIFO）：
 	按照数据或进程进入内存的顺序进行淘汰，即先进先出。这种策略实现简单，但可能无法有效保留重要或频繁访问的数据。
 
最近最少使用（LRU）：
 	根据数据最近被访问的时间来决定哪些数据应该被移除。具体来说，系统会记录每个数据项最后一次被访问的时间，当需要淘汰数据时，会选择最近最少使用的数据项进行淘汰。这种策略适用于读操作频繁，且希望保留最近被频繁访问的数据的场景。
```

![image-20241119171215125](5day-png\12内存淘汰策略.png)

```
最不经常使用（LFU）：
 根据数据被访问的频率来决定哪些数据应该被移除。系统会记录每个数据项被访问的次数，当需要淘汰数
据时，会选择最不经常使用的数据项进行淘汰。这种策略适用于读操作频繁，且希望保留被频繁访问的数据的
场景。
```

![image-20241119171359865](5day-png\12内存淘汰策略2.png)

算法复杂度

```
时间复杂度（Time Complexity）衡量的是算法执行所需的时间与输入数据规模之间的关系。它通常表示为输入大小（n）的函数。时间复杂度关注的是算法的执行速度，即随着输入数据的增大，算法所需运行时间的增长趋势。
```

```
常见的时间复杂度有：
    O(1)：常数时间，无论输入大小如何，算法的执行时间都是固定的。
    O(log n)：对数时间，算法的执行时间随着输入数据的增长而以对数速度增长。
    O(n)：线性时间，算法的执行时间与输入数据的大小成正比。
    O(n log n)：线性对数时间，算法的执行时间介于线性时间和平方时间之间。
    O(n^2)、O(n^3)、...、O(n^k)：多项式时间，算法的执行时间与输入数据的某个幂次成正比。
    O(2^n)、O(n!)：指数时间和阶乘时间，这些算法通常被认为是不切实际的，因为它们的增长速度非常快。
```

```
	空间复杂度（Space Complexity）衡量的是算法在执行过程中所占用的存储空间的大小。这包括算法本身所占用的空间（如代码和静态数据）以及算法在运行时所使用的辅助空间（如变量和临时数据结构）。

常见的空间复杂度有：
    O(1)：常数空间，算法所占用的空间是固定的，不随输入数据的增大而变化。
    O(n)：线性空间，算法所占用的空间与输入数据的大小成正比。
    O(n^2)、O(n^k)：多项式空间，算法所占用的空间随着输入数据的增大而按某个幂次增长
```

![image-20241119171725625](5day-png\12内存淘汰策略3.png)

```
同样的数据规模，不同的算法，实现相同的效果，要花多少时间，要用多少内存；
因为这些算法都是以 O开头的，所以我们将其称为 Big O
```

### 1.8进程间通信

简介

```
	进程间通信（IPC，Inter-Process Communication）是一组编程接口，它允许程序员协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。
	
	每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。
```

IPC实现方式

```
管道（PIPE）：
 	无名管道：是UNIX系统IPC最古老的形式，它是半双工的（即数据只能在一个方向上流动），具有固定的=读端和写端，只能用于具有亲缘关系的进程之间的通信（如父子进程或兄弟进程之间）。
 	命名管道（FIFO）：可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中。
 
信号量（Semaphore）：
	是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作。

共享内存（Shared Memory）：
 	指两个或多个进程共享一个给定的存储区，这是最快的一种IPC方式，因为进程是直接对内存进行存取。由于多个进程可以同时操作共享内存，因此需要进行同步，通常结合信号量使用。
 
套接字: socket
 	同一台主机上，可以通过 套接字文件 来实现双工通信。
```

```
消息队列：
 	是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识，消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除。

套接字（Socket）与Streams：
 	支持不同主机上的两个进程进行IPC。
 	
 	所谓套接字 (Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。 一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。 从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口 。
```

### 1.9进程优先级

简介

```
	进程优先级是操作系统中用于决定进程何时运行和接收多少CPU时间的一种机制。进程优先级是一个数值，用于表示进程在系统中的执行顺序。大多数操作系统中，进程优先级被划分为多个级别。
 	例如，在Windows和某些Unix-like系统中，进程优先级通常被划分为32级，从0到31，数值越低表示优先级越高。其中，0-15级通常被视为普通优先级，而16-31级则被视为实时优先级。
 	在linux2.6内核将任务优先级进行了一个划分，
 		- 实时进程优先级范围是0到MAX_RT_PRIO-1(0-99)，
 		- 普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1(100-139)
```

作用功能

```
资源分配：
 	进程优先级决定了进程在竞争CPU资源时的先后顺序。高优先级的进程会优先获得CPU时间，从而更快地完成任务。
 	说白了，就是 高优先级，可以插队。

系统响应：
 	通过调整进程优先级，可以提高系统的响应速度和性能。例如，将重要任务或实时任务的优先级提高，可以确保它们得到及时的处理。

防止进程饥饿：
 	合理的进程优先级设置可以防止低优先级进程长时间得不到执行，即防止进程饥饿问题的发生。
```

调整与设置

```
手动调整：
 	用户或系统管理员可以手动调整进程的优先级。例如，在Linux系统中，可以使用nice命令来启动一个进程并设置其优先级，或者使用renice命令来调整已运行进程的优先级。此外，还可以使用top或htop等命令来实时查看和修改进程的优先级。
 
自动调整：
 	一些操作系统会根据进程的行为和系统的负载情况自动调整进程的优先级。例如，当某个进程占用了过多的CPU时间或内存资源时，系统可能会自动降低其优先级，以给其他进程提供更多的资源。
```

![image-20241119173652354](5day-png\12进程管理优先级.png)

```
CentOS中的进程优先级通常分为系统优先级、实时优先级和nice值。
    系统优先级：0-139, 数字越小，优先级越高，各有140个运行队列和过期队列
    实时优先级: 99-0  值最大优先级最高
    nice值：-20到19，可调整，对应系统优先级100-139
 		-20表示最高优先级（即最不愿意让出CPU资源），而19表示最低优先级（即最愿意让出CPU资源）。
 		普通用户只能将自己的进程nice值调高（即降低优先级），而root用户则可以随意调整nice值。
```

ps 查看进程的nice值

```
ps axo pid,cmd,nice | head
```

用top 查看进程优先级

```
top
```

优先级越高，并不代表程序执行会更快，而是说在cpu调度时，给予更高的权重，最先执行

优先级决定的是执行顺序靠前，而不决定其程序本身要执行多久



发起进程时直接指定优先级

```shell
执行命令的时候，设定优先级
[root@rocky9 ~]# nice -n 11 ping www.baidu.com
检查优先级效果
[root@rocky9 ~]# ps axo pid,cmd,nice | grep ping
   3887 ping www.baidu.com           11
```

修改进程优先级

```shell
调整运行中的进程优先级
[root@rocky9 ~]# renice -n -10 3887
3887 (process ID) 旧优先级为 11，新优先级为 -10
检查效果
[root@rocky9 ~]# ps axo pid,cmd,nice | grep 3734
   3887 ping www.baidu.com          -10
   
越界不会报错
[root@rocky9 ~]# renice -n -30 3887
3887 (process ID) 旧优先级为 -10，新优先级为 -20
```

## 2 进程管理工具

![linux_observability_tools](5day-png\12.2管理工具.png)

Linux系统状态的查看及管理工具：

```
pstree, ps, pidof, pgrep, top, htop, glance, pmap, vmstat, dstat, kill, pkill, job, bg, fg, nohup
```

### 2.1pstree

```
pstree是一个在类Unix系统中广泛使用的命令行工具，pstree以树状图的形式显示进程及其子进程的层次结构，清晰地表达了进程间的父子关系。这种展示方式比简单的列表（如ps命令的输出）更加直观，有助于用户快速理解进程的继承关系。
```

```
pstree -p		#查看进程树
pstree -sp		#显示指定用户的进程
pstree -u		#显示父进程
```

### 2.2ps

```
	ps的英文全称是process status，意为进程状态。通过ps命令，用户可以获取当前系统中正在运行的进程的各种详细信息，如进程ID（PID）、进程状态、CPU使用情况、内存占用、运行时间等。
 	可以查看进程当前状态的快照，默认显示当前终端中的进程，Linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中
```

```
a：显示所有用户的进程，包括终端中其他用户的进程。
x：显示没有控制终端的进程（如后台服务）。
o：自定义显示的输出格式（Output）
u：选项显示进程所有者的信息
```

常用组合

```
ps -ef				#显示所有所有进程，并列出属主
ps aux  			#显示所有所有进程，并列出属主	
ps -o xx			#要显示的字段
ps -k  				#基于哪个字段进行排序
ps axo 				#显示优先级
ps -eFH				#详细格式显示所有进程
```

```shell
显示指定列
ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,comm
显示指定列
ps -axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
查询你拥有的所有进程
ps -x
查看进程的父子关系
ps auxf | head
按CPU利用率倒序排序
ps aux k -%cpu
格式化输出信息，按照cpu进行排序
ps axo pid,cmd,%cpu,%mem k -%cpu
按内存倒序排序
ps axo pid,cmd,%cpu,%mem --sort -%mem

其他常用组合
#显示指定用户名(RUID)或用户ID的进程
ps -fU apache
ps -fU 48
#显示指定用户名(EUID)或用户ID的进程
ps -fu wang
ps -fu 1000
#查看以root用户权限（实际和有效ID）运行的每个进程
ps -U root -u root
#列出某个组拥有的所有进程（实际组ID：RGID或名称）
ps -fG nginx
#列出有效组名称（或会话）所拥有的所有进程
ps -fg mysql
ps -fg 27
#显示指定的进程ID对应的进程
ps -fp 1234
#以父进程ID来显示其下所有的进程，如显示父进程为1234的所有进程
ps -f --ppid 1234
#显示指定PID的多个进程
ps -fp 1204,1239,1263
#要按tty显示所属进程
ps -ft pts/0
#以进程树显示系统中的进程如何相互链接
ps -e --forest
#以进程树显示指定的进程
ps -f --forest -C sshd
ps -ef --forest | grep -v grep | grep sshd
#要显示一个进程的所有线程,将显示LWP（轻量级进程）以及NLWP（轻量级进程数）列
ps -fL -C nginx
#要列出所有格式说明符
ps L
#查看进程的PID，PPID，用户名和命令
ps -eo pid,ppid,user,cmd
#自定义格式显示文件系统组,ni值开始时间和进程的时间
ps -p 1234 -o pid,ppid,fgroup,ni,lstart,etime
#使用其PID查找进程名称：
ps -p 1244 -o comm= #要以其名称选择特定进程，显示其所有子进程
ps -C sshd,bash
#查找指定进程名所有的所属PID，在编写需要从std输出或文件读取PID的脚本时这个参数很有用
ps -C httpd,sshd -o pid= #检查一个进程的执行时间
ps -eo comm,etime,user | grep nginx
#排序，查找占用最多内存和CPU的进程
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head
#显示安全信息
ps -eM
ps --context
#使用以下命令以用户定义的格式显示安全信息
ps -eo euser,ruser,suser,fuser,f,comm,label
#使用watch实用程序执行重复的输出以实现对就程进行实时的监视，如下面的命令显示每秒钟的监视
watch -n 1 'ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head'
```

| 字段    | 说明                                                |
| ------- | --------------------------------------------------- |
| USER    | 进程属主                                            |
| PID     | 进程ID                                              |
| PPID    | 父进程ID                                            |
| %CPU    | CPU占用率                                           |
| %MEM    | 内存占用率                                          |
| VSZ     | Virtual memory SiZe，虚拟内存集，线性内存，虚似内存 |
| RSS     | ReSident Size，常驻内存集，实际占用物理内存         |
| TTY     | 终端                                                |
| STAT    | 进程状态                                            |
| START   | 进程开始时间                                        |
| TIME    | 累计分配给进程的cpu时长                             |
| COMMAND | 对应的程序及参数                                    |
| UID     | 进程属主                                            |
| C       | cpu利用率，取整                                     |
| STIME   | 进程开始时间                                        |
| CMD     | 对应的程序及参数                                    |
| ni      | nice值                                              |
| pri     | priority 优先级                                     |
| rtprio  | 实时优先级                                          |
| psr     | processor CPU编号                                   |

进程状态字段说明

| STAT字段 | 说明                                         |
| -------- | -------------------------------------------- |
| R        | running ，运行中                             |
| S        | interruptable sleeping，可中断的睡眠状态     |
| D        | uninterruptable sleeping，不可中断的睡眠状态 |
| T        | stopped，停止态                              |
| Z        | zombie，僵尸态                               |
| +        | 前台进程                                     |
| I,大写i  | Idle kernel thread，CentOS 8 新特性          |
| L        | 内存分页并带锁                               |
| N        | 低优先级进程                                 |
| <        | 高优先级进程                                 |
| S        | session leader，会话（子进程）发起者         |
| l，小写L | 多线程进程                                   |

### 2.3prstat

```
	prtstat命令是一个用于打印指定进程统计信息的工具。它通过读取/proc/PID/stat文件（在Linux系统中），来获取并显示指定进程的统计信息。这些信息对于了解进程的运行状态、资源占用情况等非常有用。
 	可以显示进程信息，来自于psmisc包
```

```
格式
	prtstat [options] PID ...
	
选项
	-r			#信息的原始显示
```

```shell
root@openEuler:~ # pidof ping
35369
root@openEuler:~ # prtstat 35369
进程：  ping                    状态：S (暂停中)
  CPU#: 0               TTY：136:1      线程：1
进程、群组和运行阶段识别码
    进程识别号：35369                上层识别号：35309
    群组识别号：35369            运行阶段识别码：35309
  T 群组识别号：35369

分页错误
  此进程 (次要 主要)：     151         0
  子进程 (次要 主要)：       0         0
CPU 时间
  此进程 (用户 系统 访客 区块输出入)：  0.01   0.05   0.00   0.00
  子进程 (用户 系统 访客)：             0.00   0.00   0.00
内存
  Vsize：      23 MB     
  RSS：        2875 kB                   RSS 限制：18446744073709 MB
  程序开始：   0x5606a54ad000            程序停止： 0x5606a54b7e31
  堆栈开始：   0x7ffe663425b0
  堆栈指针 (ESP)：         0     指令指针 (EIP)：         0
调度
  策略：normal
  友好：0                实时优先级：0 (non RT)
```

### 2.4优先级

简介

```
进程优先级调整
    - 静态优先级：100-139
    - 进程默认启动时的nice值为0，优先级为120
    - 只有根用户才能降低nice值（提高优先性）
```

#### nice命令

```
nice命令用于在程序启动时修改其运行时的优先级。进程的优先级决定了它被CPU执行的先后顺序，优先级越高的进程占用CPU的次数越多。
```

```
格式
	nice [选项] [命令 [参数]...]
选项
	-n			#已指定优先级运行程序
```

#### renice命令

```
与nice命令不同，renice命令用于修改已经运行的进程的优先级。
```

```
renice [-n] priority pid...
```

发起进程时直接指定优先级

```shell
执行命令的时候，设定优先级
nice -n 11 ping www.baidu.com
检查优先级效果
ps axo pid,cmd,nice | grep ping
```

修改进程优先级

```shell
调整运行中的进程优先级
root@openEuler:~ # ps axo pid,cmd,nice | grep ping
  35528 ping www.baidu.com            0
  35534 grep --color=auto ping        0
root@openEuler:~ # renice -n -10 35528
35528 (process ID) 旧优先级为 0，新优先级为 -10
root@openEuler:~ # ps axo pid,cmd,nice | grep ping
  35528 ping www.baidu.com          -10
  35537 grep --color=auto ping        0
越界不会报错
root@openEuler:~ # renice -n -30 35528
35528 (process ID) 旧优先级为 -10，新优先级为 -20
root@openEuler:~ # ps axo pid,cmd,nice | grep ping
  35528 ping www.baidu.com          -20
  35540 grep --color=auto ping        0
```

### 2.5 进程搜索

#### pgrep命令

```
pgrep是Linux/Unix系统中一个用于查找与给定模式匹配的进程的命令。pgrep命令的名字来源于“process grep”的缩写，它使用pgrep来搜索与给定模式匹配的进程ID（PID）。该命令以名称为依据从运行进程队列中查找进程，并显示查找到的进程ID。每一个进程ID以一个十进制数表示，通过一个分隔符（默认为换行符）和下一个ID分开。
```

```
pgrep [options] <pattern>
选项
	-a			#显示详细完整的进程信息 
	-t			#显示指定终端的进程
	-f			#使用完整的进程名匹配
	-l			#列出进程ID和进程名
	-v			#取反
	-w			#显示线程ID
	-c			#统计匹配到的进程数量
	-g   		#指定进程的属组作为条件
    -G     		#指定 real group IDs 作为条件
    -P  		#显示指定进程的子进程
    -s   		#根据会话ID显示
    -o 			#只显示最旧的匹配进程的PID。
    -u     		#指定 effective UIDs
    -U    		#指定 real IDs，真实用户
    -x      	#根据指定的命令匹配
    -F  		#从文件中读取PID作为条件
```

```shell
查找指定终端的进程
grep -at pts/1

根据正则匹配查看进程
查看sshd所有匹配到的进程号
pgrep -f ".*sshd.*"
查看最旧的进程id
pgrep -o sshd
查看最新的进程id
pgrep -n sshd

根据用户检索进程id
root@openEuler:~ # ps aux | grep hzk
hzk        36495  0.0  0.1  24620  5604 pts/4    S+   15:05   0:00 bash
hzk        36628  0.0  0.1  24620  5824 pts/5    S    15:06   0:00 bash
hzk        36689  0.0  0.0  23224  2656 pts/5    S+   15:06   0:00 ping 1.1.1.1
root@openEuler:~ # pgrep -u hzk
36495
36628
36689

```



#### pidof命令

```
	pidof命令是Linux系统中的一个实用工具，用于查找当前正在运行的程序的进程ID（PID）.
 	pidof命令通过进程名称来查找对应的进程ID，并将结果输出到终端上。它通常用于脚本中，以确定特定的程序是否正在运行，或者在启动或停止服务之前获取其PID。
```

```
格式
	pidof [options] [program [...]]
选项
	-s			#多个结果时只显示一条
    -x			#按照脚本名称查找
    -o			#不显示指定的pid
```

```shell
root@openEuler:~ # pstree -p | grep nginx
           |-nginx(27221)-+-nginx(27222)
           |              `-nginx(27223)
root@openEuler:~ # whereis nginx
nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx
root@openEuler:~ # pidof /usr/sbin/nginx
27223 27222 27221
root@openEuler:~ # pidof nginx
27223 27222 27221
root@openEuler:~ # pidof -s nginx
27223
		#注意：如果“nginx”有多个实例在运行，该命令将只返回第一个找到的PID。
```

### 2.6进程状态

#### top

```
top 命令是一个在类 Unix 操作系统（如 Linux 和 macOS）中广泛使用的命令行工具，用于实时显示系统的运行状况，特别是各个进程的资源和性能使用情况。它提供了一个动态更新的视图，帮助系统管理员和用户监控系统的健康状态
```

```
top
选项
	-n		#刷新多少次后退出
    -d		#指定刷新时间间隔，默认为3秒
```

```
交互环境下子命令：
	P 		#以CPU使用率排序，即 %CPU字段
    M 		#以内存使用率排序，即 %MEM字段
    T 		#以CPU使用时长排序，即
TIME+字段 
    1 		#十进制数字1，在首部分开显示
每颗CPU信息
    l 		#小写L，是否显示首部top信息
    t 		#切换首部tasks及cpu显示
    m 		#切换首部内存信息显示
    s 		#修改刷新时间间隔
    k 		#终止指定进程
    q 		#退出
    h|? 	#显示帮助
```

#### htop

```
	htop是一个交互式的系统监视工具，用于查看Linux系统中正在运行的进程和资源使用情况。它提供了比传统的top命令更丰富的信息和功能，并以彩色方式展示进程列表，使得用户可以更直观地了解系统的运行状态。
 	注意：htop 是增强版的 top 命令，在 centos 中来自于 epel 源， ubuntu 中可以直接安装
```

```
htop
选项
	-d		#指定刷新时间
	-u		#仅显示指定用户的进程
	-s		#以指定字段进行排序
```

```
子命令
    s 		#跟踪选定进程的系统调用
    l 		#显示选定进程打开的文件列表
    a 		#将选定的进程绑定至某指定
CPU核心
    t 		#显示进程树
```

```shell
top - 15:20:13 up 1 day, 19:22,  6 users,  load average: 0.00, 0.01, 0.06
Tasks: 230 total,   2 running, 228 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.2 hi,  0.2 si,  0.0 st 
MiB Mem :   3372.8 total,   2359.0 free,    605.0 used,    642.8 buff/cache     
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   2767.8 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                                                                  
      1 root      20   0   79496  47388  10024 S   0.0   1.4   0:02.83 systemd                                                                                                                                  
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.04 kthreadd  
      
      
字段解析
    us 用户空间 	sy 内核空间 	ni 调整nice时间   		id 空闲
    wa 等待IO时间 	hi 硬中断 		 si 软中断（模式切换） 	  st 虚拟化消耗占比
```

### 2.7free

```
free命令是Linux系统中用于显示内存使用情况的常用工具。free命令能够显示Linux系统中空闲的、已用的物理内存及swap内存，以及被内核使用的buffer和cache。它提供了系统内存使用情况的快照，帮助用户了解系统的内存资源分配和消耗情况。
```

```
free [options]
选项
	-m			#以MB为单位显示
	-h			#以人类友好阅读的形式显示
	-l			#显示峰值和谷值
	-s N		#每隔N秒刷新一次
	-c N		#输出N次后退出
```

buffer/cache

```
	缓冲(buffers) 是指在写磁盘时，先把要写的数据放入一个缓冲区，然后再批量写，以减少磁盘碎片和硬盘反复寻道，从而提高系统性能。
 	buffers 主要用于硬盘与内存之间的数据交互。
 	缓存(cached) 是指文件的内容要被多个进程使用的时候，则可以将内容放入缓存区，则后续就可以直接从内存中读，而不用再消耗IO。
 	cached主要作用于CPU和内存之间的数据交互（本来要用IO读硬盘文件，现在变成了读内存）。
```

![image-20241119200457588](5day-png\12内存.png)

清理缓存

```
	向/proc/sys/vm/drop_caches中写入相应的修改值，会清理缓存。建议先执行sync（sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件）。执行echo1、2、3 至 /proc/sys/vm/drop_caches, 达到不同的清理目的。
 	如果因为是应用有像内存泄露、溢出的问题时，从swap的使用情况是可以比较快速可以判断的，但通过执行free 反而比较难查看。但核心并不会因为内存泄露等问题并没有快速清空buffer或cache（默认值是0），生产也不应该随便去改变此值。
 	一般情况下，应用在系统上稳定运行了，free值也会保持在一个稳定值的。当发生内存不足、应用获取不到可用内存、OOM错误等问题时，还是更应该去分析应用方面的原因，否则，清空buffer，强制腾出free的大小，可能只是把问题给暂时屏蔽了。
 	排除内存不足的情况外，除非是在软件开发阶段，需要临时清掉buffer，以判断应用的内存使用情况；或应用已经不再提供支持，即使应用对内存的时候确实有问题，而且无法避免的情况下，才考虑定时清空buffer。
```

```
字段说明
    total 		#内存总量
    used 		#已经使用的内存
    free 		#空闲的内存
    shared 		#多个进程共享的内存
    buff/cache 	#缓冲和缓存使用的内存
    available 	#可用内存
```

清理缓存

```
root@openEuler:~ # free -m
               total        used        free      shared  buff/cache   available
Mem:            3372         588        2437           9         580        2784
Swap:              0           0           0
root@openEuler:~ # echo 3 > /proc/sys/vm/drop_caches 
root@openEuler:~ # free -m
               total        used        free      shared  buff/cache   available
Mem:            3372         506        2947           9          76        2865
Swap:              0           0           0

结果显示：
 	内存中的buff/cache 量少多了
```

### 2.8pmap

#### pmap命令

```
	pmap命令是一个用于报告Linux进程内存映射关系的工具，它显示了进程的内存使用情况，包括代码段、数据段、堆栈等详细信息。这个命令对于理解进程内存布局和排查内存问题非常有帮助。
 	pmap实际上是一个Sun OS上的命令，Linux系统仅支持其有限的功能。
```

```
pmap [options] PID [PID ...]
选项
	-x      	#显示详细信息
    -X      	#显示更详细信息
    -d      	#显示设备
    -q      	#显示时不显示头尾
    -p      	#显示映射表中的完整路径
    -A			#指定内存地址起始位置
```

```
root@openEuler:~ # pstree -p | grep sshd
           |-sshd(1104)---sshd(26127)---sshd(26131)-+-bash(26132)-+-grep(40476)
r
oot@openEuler:~ # pmap 1104
1104:   sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
00005571339dd000     60K r---- sshd
00005571339ec000    528K r-x-- sshd

root@openEuler:~ # pmap -x 1104
1104:   sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
Address           Kbytes     RSS   Dirty Mode  Mapping
00005571339dd000      60      60       0 r---- sshd
00005571339ec000     528     440       0 r-x-- sshd
0000557133a70000     348     188       0 r---- sshd
0000557133ac7000      16      16      16 r---- sshd
0000557133acb000       4       4       4 rw--- sshd

root@openEuler:~ # pmap -pd 1104
1104:   sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
Address           Kbytes Mode  Offset           Device    Mapping
00005571339dd000      60 r---- 0000000000000000 0fd:00000 /usr/sbin/sshd
00005571339ec000     528 r-x-- 000000000000f000 0fd:00000 /usr/sbin/sshd
0000557133a70000     348 r---- 0000000000093000 0fd:00000 /usr/sbin/sshd
0000557133ac7000      16 r---- 00000000000ea000 0fd:00000 /usr/sbin/sshd
0000557133acb000       4 rw--- 00000000000ee000 0fd:00000 /usr/sbin/sshd
```

### 2.9 vmstat

```
	vmstat命令生成的报告可用于平衡系统负载活动，帮助用户快速获取当前系统的负载情况，进行系统性能调优、故障排查等操作。具体来说，它可以：
```

```
监测系统的整体负载情况:
 	了解系统的CPU、内存、磁盘、网络等性能指标，以及进程数量和状态等信息。

分析系统性能问题:
 	通过观察系统的CPU使用率、内存占用、磁盘I/O等指标，快速定位系统的性能瓶颈，找到导致系统负载过高、响应变慢等问题的原因。

监测系统的稳定性:
 	通过连续监测系统的负载情况，识别出系统的周期性波动，以及系统负载变化的规律，从而更好地管理系统资源，保证系统的稳定性。
```

```
vmstat [options] [delay [count]]
选项
	--disk			#磁盘信息
	-s				#显示事件统计
```

显示项说明

```
procs:
r 		#可运行（正运行或等待运行）进程的个数，和核心数有
关
b 		#处于不可中断睡眠态的进程个数(被阻塞的队列的长
度)

memory:
 swpd 			#交换内存的使用总量
 free 			#空闲物理内存总量
 buffer 		#用于buffer的内存总量
 cache 			#用于cache的内存总量

swap:
 si 			#从磁盘交换进内存的数据速率(kb/s)
 so 			#从内存交换至磁盘的数据速率(kb/s)

io：
 bi 			#从块设备读入数据到系统的速率(kb/s)
 bo 			#保存数据至块设备的速率

system:
 in 			#interrupts 中断速率，包括时钟
 cs 			#context switch  进程切换速率

cpu:
 us 			#Time spent running non-kernel code
 sy 			#Time spent running kernel code
 id 			#Time spent idle. Linux 2.5.41前,包括IOwait time.
 wa 			#Time spent waiting for IO.  2.5.41前，包括in idle.
 st 			#Time stolen from a virtual machine.2.6.11前, unknown.
```

### 2.10 lsof

lsof 查看进程打开文件

```
	lsof：list open files，查看当前系统文件的工具。在linux环境下，一切皆文件，用户通过文件不仅可以访问常规数据，还可以访问网络连接和硬件如传输控制协议 (TCP) 和用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分配了一个文件描述符 。
```

```
lsof [options...] [names]
选项
	-Pti 			#根据端口获取进程id
	-i condition 	#列出符合条件的进程
	-t				#只更新打开文件的表，而不显示它们
```

### 2.11 信号发送kill

#### kill 信号发送

```
kill命令是在Unix和类Unix操作系统（如Linux）中使用的命令，主要用于向进程发送信号，通常用于终止进程。
```

```
kill [options]… <pid>
 
常见选项
    -SIGNAL 		#信号名称
    -s SIGNAL 		#指定信号
    
一般选项
    -u uid 			#effective user，生效者
    -U uid 			#real user，真正发起运行命令者
    -t terminal 	#与指定终端相关的进程
    -l|-L 			#显示信号名（pgrep可用）,不跟进程则列出所有信号
    -a 				#显示完整格式的进程名（pgrep可用）
    -P pid 			#显示指定进程的子进程
```

#### kill & killall & pkill

```
kill命令：
    用于终止指定进程的运行。
    需要通过"进程ID"（PID）来指定要终止的进程。
    可以发送多种信号给进程，其中SIGTERM（默认）和SIGKILL是两种常用的信号。
    
killall
    用于终结指定名称的所有进程。
    通过"进程名称"来匹配并终止进程，而不是进程ID。
    同样可以发送多种信号，但默认也是发送SIGTERM信号。
    
pkill命令：
 用于根据进程名或信号终止进程，功能类似于killall，但提供了更多选项。
 可以直接跟进程名称，也可以跟其他选项来指定终止条件。
 同样可以发送多种信号。
    高级功能：
        可以根据终端号踢出用户登录。
        可以根据用户名终止所有进程。
        可以使用模糊匹配来终止进程名包含特定字符串的进程。
```

常用信号：

```
1) SIGHUP 无须关闭进程而让其重读配置文件
2) SIGINT 中止正在运行的进程；相当于Ctrl+c
3) SIGQUIT 相当于ctrl+\
9) SIGKILL 强制杀死正在运行的进程,可能会导致数据丢失,慎用!
15) SIGTERM 终止正在运行的进程，默认信号
18) SIGCONT 继续运行
19) SIGSTOP 后台休眠
信号的使用方式
    1. 使用信号的数字标识， 如 1，2，3
    2. 使用信号的完整名称，不区分大小写，  如 SIGHUP,  sighup
    3. 使用信号的简写名称，不区分大小写，如 HUP，hup
```

利用 0 信号实现进程的健康性检查

### 2.12作业管理

linux的作业控制

```
- 前台作业：通过终端启动，且启动后一直占据终端
- 后台作业：可通过终端启动，但启动后即转入后台运行（释放终端）
```

![image-20241119204530599](5day-png\12.作业管理.png)

让作业运行于后台

```
- 运行中的作业： Ctrl+z
- 尚未启动的作业： COMMAND &
```

后台作业虽然被送往后台运行，但其依然与终端相关；退出终端，将关闭后台作业。如果希望送往后台后，剥离与终端的关系

```
- nohup COMMAND &>/dev/null &
- screen；COMMAND
- tmux；COMMAND
```

作业控制：

```
fg [[%]JOB_NUM] 		#把指定的后台作业调回前台
bg [[%]JOB_NUM] 		#让送往后台的作业在后台继续运行
kill [%JOB_NUM] 		#终止指定的作业
```

```
查看当前终端所有作业：
jobs
作业控制，调出后台进程
fg
fg 2
让后台stop 进程继续running
bg
bg1
```

### 2.13并行运行

简介

```
	Shell的并行运行是指在同一时间内，使用多个shell进程来执行不同的任务，以提高系统的性能和效率。这种方法在处理大量任务或需要长时间运行的任务时尤为有效。
```

原理解读

```
	并行运行允许同时执行多个命令或多个脚本实例，而无需按顺序一个接一个地执行。这可以充分利用多核CPU的优势，大幅提高任务处理速度，减少等待时间。
```

实现并行运行的方法

```
使用后台执行符&：
 	在shell命令后面加上&符号，可以将该命令放入后台执行。例如：
 	短命令并行执行：command1 & command2 &
 	长命令并行执行：{ command1; command2; command3;}&
使用管道符号：
 	需要注意的是，虽然管道符号（|）通常用于将多个命令连接起来，并将前一个命令的输出作为后一个命令的输入，但在某些情况下，结合其他命令（如xargs）也可以实现并行处理。然而，这并不是纯粹的并行执行多个独立任务的方法。
```

```
使用并行命令（parallel）：
 	parallel是一个非常强大的命令行工具，能够利用多核处理器的能力，执行多个命令的并行处理。它广泛适用于Linux和Unix系统中。
 	安装parallel可以通过包管理器进行，如apt（用于Debian系系统）、yum（用于Red Hat系系统）等。
 	使用parallel时，可以将要执行的命令作为parallel的参数，而需要处理的数据则通过管道（|）或其他方式传递给parallel。
```

```
使用循环和数组/临时文件队列机制：
 	在shell脚本中，可以通过循环和数组或临时文件队列机制来管理和调度并行任务。这种方法需要一定的脚本编写技巧，但可以实现更复杂的并行任务调度和控制。

使用FIFO文件：
 	FIFO（First In First Out）文件是一种特殊的文件类型，用于实现进程间的通信。通过创建FIFO文件，可以将任务放入队列中，并由多个并行执行的进程依次处理。
```

```shell
root@openEuler:~ # cat proc1.sh 
#!/bin/bash
echo "进程1运行中..."
sleep 1
echo "进程1运行完毕!!!"
root@openEuler:~ # cat proc2.sh 
#!/bin/bash
echo "进程1运行中..."
sleep 2
echo "进程1运行完毕!!!"
root@openEuler:~ # cat proc3.sh 
#!/bin/bash
echo "进程1运行中..."
sleep 3
echo "进程1运行完毕!!!"

root@openEuler:~ # cat exec_proc1.sh 
#!/bin/bash
start_time=$(date "+%F %T")
echo "${start_time}: 开始执行程序"
/bin/bash proc1.sh&
/bin/bash proc2.sh&
/bin/bash proc3.sh&
wait
end_time=$(date "+%F %T")
echo "${end_time}: 所有程序执行完毕"
root@openEuler:~ # cat exec_proc2.sh 
#!/bin/bash
start_time=$(date "+%F %T")
echo "${start_time}: 开始执行程序"
/bin/bash proc1.sh&
/bin/bash proc2.sh&
/bin/bash proc3.sh&
wait
end_time=$(date "+%F %T")
echo "${end_time}: 所有程序执行完毕"

root@openEuler:~ # cat exec_proc2.sh 
#!/bin/bash
start_time=$(date "+%F %T")
echo "${start_time}: 开始执行程序"
/bin/bash proc1.sh
/bin/bash proc2.sh
/bin/bash proc3.sh
end_time=$(date "+%F %T")
echo "${end_time}: 所有程序执行完毕"

root@openEuler:~ # cat exec_proc2.sh 
#!/bin/bash
start_time=$(date "+%F %T")
echo "${start_time}: 开始执行程序"
/bin/bash proc1.sh
/bin/bash proc2.sh
/bin/bash proc3.sh
end_time=$(date "+%F %T")
echo "${end_time}: 所有程序执行完毕"
root@openEuler:~ # /bin/bash exec_proc2.sh 
2024-11-19 21:14:24: 开始执行程序
进程1运行中...
进程1运行完毕!!!
进程1运行中...
进程1运行完毕!!!
进程1运行中...
进程1运行完毕!!!
2024-11-19 21:14:30: 所有程序执行完毕
```

```shell
 #!/bin/bash
  2 #顺序执行
  3 net=10.0.0
  4 for i in {1..254}
  5 do
  6   ping -c1 -W1 $net.$i &> /dev/null && echo $net.$i is up || echo $net.$i is down 
  7 done
  8 #并发执行
  9 net=10.0.0
 10 for i in {1..254}
 11 do
 12  {
 13     ping -c1 -W1 $net.$i &> /dev/null && echo $net.$i is up || echo $net.$i is down                                                                                           
 14  }&
 15 done
 16 wait
```

## 3其他管理工具

### 3.1cpu负载

#### uptime命令

```
uptime命令对于系统管理员和开发人员来说非常有用，因为它可以快速提供系统的运行时间和负载情况。这些信息有助于管理员了解系统的工作状况，及时采取相应措施来优化系统性能或解决潜在问题。
```

```
top  第一行的后面 就是和cpu相关的
     第三行   和cpu 相关
```

```
uptime
```

```
21:30:06 up 1 day, 21:09,  1 user,  load average: 0.00, 0.02, 0.08
 	
 	21:30:06 							#系统当前时间
    up 1 day, 21:09 					#系统己开机运行时长
    1 user 								#当前有三个用户登录
    oad average: 0.00, 0.02, 0.08 		#系统的平均负载，1分钟，5分钟，15分钟
```

```
	系统平均负载：指在特定时间间隔内运行队列中的平均进程数，通常每个CPU内核的当前活动进程数不大于3，那么系统的性能良好。如果每个CPU内核的任务数大于5，那么此主机的性能有严重问题。
	如：linux主机是1个双核CPU，当Load Average 为6的时候说明机器已经被充分使用
```

#### w命令

```
	w是Linux操作系统中的一个常用命令，它主要用于显示当前登录到系统的用户信息以及系统的负载情况。w命令能够列出当前登录到系统的所有用户，以及他们的活动情况，包括用户名、登录终端、登录时间、远程主机、闲置时间、CPU使用情况以及他们正在执行的命令等。此外，w命令还提供系统负载信息，如平均负载和CPU使用率，帮助管理员监控系统的整体运行状况。
 	注意：执行w命令需要一定的权限。普通用户只能查看自己的信息，而管理员或root用户可以查看所有用
户的信息。
```

```
w
```

```
root@openEuler:~ # w
 21:32:51 up 1 day, 21:12,  1 user,  load average: 0.00, 0.00, 0.06
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0     21:06    1.00s  0.15s   ?    w
```

```
属性解读
    USER：显示当前登录的用户名。
    TTY：显示用户使用的终端名称。如果用户通过SSH登录，TTY列会显示远程主机的IP地址或主机名。
    FROM：显示用户从哪台远程主机登录到系统（如果适用）。
    LOGIN@：显示用户的登录时间，包括日期和时间。
    IDLE：显示用户的闲置时间，即从用户最后一次与终端交互到现在所持续的时间。
    JCPU：显示该终端上所有进程及子进程使用系统的总时间。
    PCPU：显示当前活动进程（在WHAT字段中提到的进程）使用系统的时间。
    WHAT：显示用户当前正在执行的命令或程序。
```

#### mpstat命令解析

```
	mpstat是Linux系统中一个用于监控多核CPU性能和使用情况的命令行工具，全称为Multiprocessor Statistics（多处理器统计）。
 	mpstat能够显示每个CPU或CPU核心的活动统计信息，帮助用户分析系统的CPU使用情况，从而进行性能调优。它是sysstat软件包的一部分，如果系统中未安装该软件包，需要先进行安装。
```

```
root@openEuler:~ # mpstat
Linux 6.6.0-28.0.0.34.oe2403.x86_64 (openEuler)         2024年11月19日  _x86_64_        (2 CPU)

21时36分18秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
21时36分18秒  all    0.02    0.00    0.11    0.00    0.08    0.04    0.00    0.00    0.00   99.75
```

```
Centos系统
 yum install sysstat -y
Ubuntu系统
 apt install sysstat -y
```

```
命令格式：
 mpstat [ options ] [ <interval> [ <count> ] ]
常用选项
    -P {cpu_list|ALL} #查看指定CPU，可以写成 0,1,2 0-2   2-
    -I {SUM|CPU|SCPU|ALL} #显示指定中断数
    -o JSON #以JSON格式输出
```

### 3.2设备信息

#### iostat命令

```
	iostat命令是I/O statistics（输入/输出统计）的缩写，主要用于监视系统的磁盘输入/输出（I/O）活动，提供有关磁盘使用情况和磁盘性能的实时统计信息。同时，它也可以报告系统的CPU统计信息。
	该命令依赖于 sysstat 包
```

```
iostat [ options ] [ <interval> [ <count> ] ]
```

```
一般选项
    -c 				#只显示CPU行
    -d 				#显示设备〈磁盘)使用状态
    -k 				#以千字节为为单位显示输出
    -h 				#以方便阅读的方式显示
    -t 				#在输出中包括时间戳
    -x 				#在输出中包括扩展的磁盘指标
```

```shell
root@rocky9:a # iostat
Linux 5.14.0-427.13.1.el9_4.x86_64 (rocky9)     11/20/2024      _x86_64_        (2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.04    0.01    0.19    0.00    0.00   99.77

Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd
dm-0              0.38         6.21         8.29         0.00     643851     859300          0
         0
sda               0.30         6.91         8.65         0.00     716563     896770          0
sdb               0.00         0.15         0.00         0.00      15743          0          0
sr0               0.00         0.02         0.00         0.00       2096          0          0
```

```
属性解析：
    tps 		#该设备每秒的传输次数，多个逻辑请求可能会被合并为一次I/O请求
    kB_read/s 	#每秒从设备（drive expressed）读取的数据量；
    kB_wrtn/s 	#每秒向设备（drive expressed）写入的数据量；
    kB_read 	#读取的总数据量
    kB_wrtn 	#写入的总数量数据量；这些单位都为Kilobytes。
```

```
默认显示CPU信息和所有设备信息：iostat
只显示CPU的信息：iostat -c
每隔2秒显示一次设备统计信息，总共输出3次：iostat -d 2 3
每隔2秒显示一次sda及上面所有分区的统计信息，共输出3次：iostat -p sda 2 3
以MB为单位显示所有信息：iostat -m
显示指定硬盘信息：iostat -d sda
显示设备的详细信息：iostat -x sda
```

#### iotop命令

```
	iotop命令是一个用来监视磁盘I/O使用状况的top类工具iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息，可查看每个进程是如何使用IO.
 	该命令依赖于 iotop 软件包
```

```
命令格式
	iotop
交互式子命令：
    left/right 		#改变排序列
    r 				#反向排序
    o 				#切换至选项--only
    p 				#切换至--processes选项
    a 				#切换至--accumulated选项
    q 				#退出
    i 				#改变线程的优先级
```

### 3.3网络信息

#### iftop 显示网络带宽使用情况

显示网络信息

```
iftop是一款开源的、实时的、基于命令行的网络流量监控工具，以下是关于iftop的详细介绍：
    实时监控网络带宽使用情况，包括发送和接收的带宽。
    显示TCP和UDP连接的源和目标地址。
    显示端口连接信息以及反向解析IP。
    精确显示本机网络流量及网络内各主机和本机相互通信的流量集合。
    检测流量异常的主机，有助于网络故障排查和网络安全检测。
注意：
 	iftop软件包在 epel-release源里面
```

#### nload 查看网络实时吞吐量

```
nload是一个用于实时监控Linux系统网络流量的命令行工具。
    实时监控：
   nload能够实时显示网络接口的流量信息，包括进入和离开网络接口的流量。
    直观显示：
   nload的界面分为上下两部分，分别显示进入和离开网络接口的流量，
   同时提供当前流量、平均流量、最小流量、最大流量和总和流量等统计信息。
    易于操作：
   nload支持通过键盘快捷键在网卡之间切换，以及显示选项窗口、保存和重新加载设置等功能。
   
注意：
 nload软件包在 epel-release源里面
```

```
命令格式：
 nload [options] [devices]
一般选项
    -m             				#显示所有设备
    -t N     					#数据刷新频率，单位毫秒，默认500
    -u h|b|k|m|g|H|B|K|M|G   	#显示单位(h auto, b Bit/s, B Byte/s) 
    -U h|b|k|m|g|H|B|K|M|G   	#总流量显示单位
    devices         			#指定设备
```

```
界面操作：
 上下方向键、左右方向键、enter键或者tab键都就可以切换查看多个网卡的流量情况
    按 F2 显示选项窗口
    按 q 或者 Ctrl+C 退出 nload
```



#### nethogs 查看进程网络带宽的使用情况

```
nethogs是一个基于命令行的网络监控工具，用于实时监视每个进程的网络流量。   
   实时监控：
   		nethogs能够实时显示每个进程的网络带宽使用情况，包括上传和下载速度。
   详细统计：
   		除了实时的速度显示，nethogs还可以显示每个进程的总流量、连接数和数据包数量等信息。
   易于使用：
   		nethogs的界面以表格形式呈现，清晰直观，用户可以通过上下方向键滚动页面查看不同进程的网络使用情况。
   多种选项：
   		nethogs提供了多种命令行选项，允许用户自定义监控的网卡、刷新间隔、流量显示模式等。
   交互操作：
   		在nethogs运行时，用户可以通过按键进行交互操作，如排序、切换显示模式等。
   
注意：
 nethogs软件包在 epel-release源里面
```

```
命令格式：
 nethogs [-h] [-V] [-d] [-v] [-t] [-c] [-p] [-s] [device(s)]
一般选项
 	-d 			#数据刷新时间间隔，默认1秒
    -v 			#显示单位(0 KB/s|1 total KB|2 total B|3 total MB)
    -t 			#跟踪显示
    -s 			#按发送数据量排序
    -a 			#显示所有设备数据，包含回环设备
    device 		#指定设备
```

```
交互式命令：
    q 退出
    s 根据发送数据量排序
    r 根据接收数据量排序
    m 切换显示单位
```

#### iptraf-ng 网络监视工具

```
iptraf-ng是一个专为Linux设计的命令行网络监测程序，它能够实时展示关于IP流量的各种信息。
   实时监测：
  		iptraf-ng能够实时监测网络流量、连接状态、带宽使用情况等信息。
   详细统计：
   		该工具可以提供TCP连接状态、不同类型的IP包、端口统计、IP地址统计以及接口活动等详细网络情况。
   图形界面：
   		iptraf-ng提供了基于ncurses的图形界面，使得用户可以通过更直观的方式查看网络流量信息。
   跨平台支持：
   		支持包括Fedora、RHEL、CentOS、Ubuntu、Debian等多个主流Linux发行版。
   模块化设计：
   		易于扩展和定制，可以满足特定需求。
注意：
iptraf-ng软件包在 epel-release源里面
```

### 3.4系统资源

#### dstat 系统资源统计



#### glances 综合监控工具



### 3.5cockpit

```
Cockpit是一个免费且开源的基于Web的Linux服务器管理工具，提供了友好的Web前端界面，方便用户监视和管理GNU/Linux服务器。
    - 监控系统活动（CPU、内存、磁盘 IO 和网络流量）
    - 查看系统日志条目
    - 查看磁盘分区的容量
    - 查看网络活动（发送和接收）
    - 查看用户帐户
    - 检查系统服务的状态
    - 提取已安装应用的信息
    - 查看和安装可用更新（如果以 root 身份登录）并在需要时重新启动系统
    - 打开并使用终端窗口
```

插件管理

```
Cockpit支持通过插件扩展功能，如虚拟机管理、存储管理等。可使用包管理器（如yum或dnf）安装相应的Cockpit插件，如cockpit-machines用于虚拟机管理，cockpit-storaged用于存储管理。
 
管理虚拟机：
 	安装cockpit-machines插件后，可在Cockpit Web界面中管理KVM、oVirt等虚拟机。
 	可执行创建、删除、启动、停止等虚拟机操作。
存储管理：
 	使用cockpit-storaged插件可管理包括LVM、RAID、NFS等在内的存储配置。
 	可执行磁盘分区、格式化、挂载等操作。
```

## 4 计划任务

### 4.1基本概念

Linux系统中主要有两种计划任务类型

```
at计划任务：
    用于在指定的绝对时间或相对时间执行一次任务。
    需要atd服务的支持。
    可以使用at命令来添加、查看或删除计划任务。
    权限控制通过/etc/at.allow和/etc/at.deny文件实现。
    
cron计划任务：
    用于在指定的时间段或周期执行重复性的任务。
    需要crond服务的支持。
    可以使用crontab命令来添加、查看或编辑计划任务。
    权限控制通过/etc/cron.allow和/etc/cron.deny文件实现。
```

| 任务类型   | 说明                         | 实现程序 |
| ---------- | ---------------------------- | -------- |
| 一次性任务 | 未来的某时间点执行一次的任务 | at,batch |
| 周期性任务 | 根据条件周期性执行           | cron     |

### 4.2一次性任务

#### at命令

```
at 命令是 Linux 和 Unix 系统中的一个用于安排一次性任务在指定时间执行的命令。它允许用户指定一个命令或脚本，以及执行该命令的时间。任务会被放入系统的任务队列中，并在指定的时间由 atd（at daemon）服务执行。
```

```
- 由包 at 提供
- 依赖与atd服务，需要启动才能实现at任务
- at队列存放在/var/spool/at目录中，ubuntu存放在/var/spool/cron/atjobs目录下
- 执行任务时PATH变量的值和当前定义任务的用户身份一致
- 作业执行命令的结果中的标准输出和错误以执行任务的用户身份发邮件通知给 root 
- 默认CentOS 8 最小化安装没有安装邮件服务，需要自行安装
```

```
at -xxxx		#执行一个任务
at -l  			#查看任务
at -d 			#删除任务
at -c N			#查看第N个任务
```

```
创建at任务有三种方式：交互式创建，输入重定向，at -f FILE
```

### 4.3周期性任务

#### cron简介

```
cron 服务相关程序：
    - cronie：主程序包，提供crond守护进程及相关辅助工具
    - crontabs：包含CentOS提供系统维护任务
    - cronie-anacron：cronie的补充程序，用于监控cronie任务执行状况，
   		如:cronie中的任务在过去该运行的时间点未能正常运行，则anacron会随后启动一次此任务
```

cron 依赖于crond服务，确保crond守护处于运行状态：

```
#CentOS 7 以后版本:
systemctl status crond
#CentOS 6:
service crond status
```

cron任务分类

```
系统cron任务
 	操作系统自带的cron 任务，系统维护作业，/etc/crontab 主配置文件， /etc/cron.d/ 子配置文件
 
用户cron任务
 	每个用户自己名下的 cron 任务
 	红帽系统保存在 /var/spool/cron/USERNAME，
 	Ubuntu 系统存放在/var/spool/cron/crontabs/USERNAME，利用 crontab 命令管理
```

系统cron 任务相关文件

```
/etc/crontab 		#配置文件
/etc/cron.d/ 		#配置文件
/etc/cron.hourly/ 	#脚本
/etc/cron.daily/ 	#脚本
/etc/cron.weekly/ 	#脚本
/etc/cron.monthly/ 	#脚本
```

计划任务时间表示法

```
root@rocky9:~ # cat /etc/crontab 
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed

综合用法
    */5 1,3,5-8 * * 2,4 		#每周2和每周4的第1时，第3时，第5到8时，每5分钟执行一次
    1 2 1-10 * 1-5 				#每月的1到10日，或每周1到周五的2时1分执行一次  
    1-30/5 * * * * 				#每小时1-30分内，每5分钟执行一次
```

### 4.4用户计划任务

crontab命令

```
命令格式
 crontab [-u user] [-l | -r | -e] [-i]
 
常用选项
    -l 			#列出所有任务
    -e 			#编辑任务
    -r 			#移除所有任务
    -i 			#同-r一同使用，以交互式模式移除指定任务
    -u user 	#管理特定用户的cron, 仅root有权限操作
```

cron中的环境变量

```
	cron中的环境变量和bash 中的环境变量不一致，所以在写 cron 任务时，命令路径要求写全路径，或先在首部先定义PATH。
```

### 4.5cron补充

cron 中 % 的用法

```
	cron任务中不建议使用%，它有特殊用途，它表示换行的特殊意义，且第一个%后的所有字符串会被将成当作命令的标准输入，如果在命令中要使用%，则需要用 \ 转义。
 	注意：将%放置于单引号中是不支持的
```

```
30 2 * * * /bin/cp -a /etc/ /data/etc`date +\%F_\%T`
30 2 * * * /bin/cp -a /etc/ /data/etc`date +‘%F_%T’`   		#错误写法
```

控制用户执行计划任务

```
/etc/cron.{allow,deny} 			#ubuntu中无此文件
```







20250316
